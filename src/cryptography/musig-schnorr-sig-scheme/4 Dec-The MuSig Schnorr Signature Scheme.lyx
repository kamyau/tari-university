#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
The MuSig Schnorr Signature Scheme
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Standard
This report investigates MuSig, which is provably secure in the 
\emph on
plain public-key model
\emph default
.
 However, the case of interactive signature aggregation where each signer
 signs their own message must still be proven by a complete security analysis.
 
\end_layout

\begin_layout Standard
Multi-signatures are a form of technology used to add additional security
 for cryptocurrency transactions.
 A multi-signature protocol which allows a group of signers to produce a
 short, joint signature on a common message.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Schnorr Signatures for Bitcoin 
\end_layout

\begin_layout Standard
Schnorr signatures produce a smaller on-chain size, support faster validation
 and have better privacy.
 They natively allow for combining multiple signatures into one through
 aggregation.
 They permit more complex spending policies, including 
\emph on
k
\emph default
-of-
\emph on
n
\emph default
 and more to be represented as as single signature for a single key.
\end_layout

\begin_layout Standard
Signature aggregation also has its challenges.
 This included the rogue-key attack, where a participant steals funds using
 a specifically constructed key.
 This is easily solved for simple multi-signatures, however, through an
 enrollment procedure, where the keys sign themselves, supporting it across
 multiple inputs of a transaction requires plain public-key security, meaning
 there is no setup.
 
\end_layout

\begin_layout Standard
An additional attack, termed the Russel attacks, after Russel O'Connor,
 who was discovered for multi-party schemes where a party could claim ownership
 of someone else's key and so spend their other outputs.
 
\end_layout

\begin_layout Standard
Peter Wuille discussed the issues and their solutions, which refines the
 Bellare-Neven (BN) scheme.
 He also discussed the performance improvements that were implemented for
 the scaler multiplication fo the BN scheme and how they enable batch validation
 on the blockchain.
 A pair of BIPs are in process to make these advances a reality for Bitcoin.
\begin_inset CommandInset citation
LatexCommand cite
key "Blocks2018"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Key Aggregation for Schnorr Signatures 
\end_layout

\begin_layout Standard
MuSig is a simple multi-signature scheme that is novel in combining:
\end_layout

\begin_layout Enumerate
Support for key aggregation; 
\end_layout

\begin_layout Enumerate
Security in the plain public-key model.
 
\end_layout

\begin_layout Standard
There are two versions of MuSig, that are provably secure, which differ
 based on the number of communication rounds:
\end_layout

\begin_layout Itemize
Three-round MuSig only relies on the Discrete Logarithm (DL) assumption,
 on which ECDSA (Elliptic Curve Digital Signature Algorithm) also relies
 
\end_layout

\begin_layout Itemize
Two-round MuSig instead relies on the slightly stronger One-More Discrete
 Logarithm (OMDL) assumption
\end_layout

\begin_layout Standard
A multi-signature scheme is a combination of a signing and verification
 algorithm, where multiple signers (each with their own private/public key)
 jointly sign a single message, resulting in a single signature.
 This can then be verified by anyone knowing the message and the public
 keys of the signers.
 
\end_layout

\begin_layout Standard
Note: in the context of Bitcoin, the term 'multisig' refers to a 
\emph on
k
\emph default
-of-
\emph on
n
\emph default
 policy, where 
\emph on
k
\emph default
 can be different from 
\emph on
n
\emph default
.
 While in the cryptographic literature, the term multi signature really
 only refers to 
\emph on
n
\emph default
-of-
\emph on
n
\emph default
 policies, however, 
\emph on
k
\emph default
-of-
\emph on
n
\emph default
 can be constructed on top of 
\emph on
n
\emph default
-of-
\emph on
n
\emph default
.
\end_layout

\begin_layout Standard
The term 
\emph on
key aggregation
\emph default
 refers to multi-signatures that look like a single-key signature, but with
 respect to an aggregated public key that is a function of only the participants
' public keys.
 Thus, verifiers do not require the knowledge of the original participants'
 public keys- they can just be given the aggregated key.
 In some use cases, this leads to better privacy and performance.
 MuSig is effectively a key aggregation scheme for Schnorr signatures.
 
\end_layout

\begin_layout Standard
There are other multi-signature schemes that already exist that provide
 key aggregation for Schnorr signatures, however they come with some limitations
, such as needing to verify that participants actually have the private
 key corresponding to the pubic keys that they claim to have.
 
\emph on
Security in the plain public-key model 
\emph default
means that no limitations exist.
 All that is needed from the participants is their public keys.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wuille2018"
literal "false"

\end_inset

 
\end_layout

\begin_layout Subsection
Applications of mulit-signatures in Bitcoin 
\end_layout

\begin_layout Standard
The most obvious use case for mulit-signatures with regards to Bitcoin is
 as a more efficient replacement of 
\emph on
n
\emph default
-of-
\emph on
n
\emph default
 multisig scripts and other policies that permit a number of possible combinatio
ns of keys (including 
\emph on
k
\emph default
-of-
\emph on
n
\emph default
, using key trees, MAST, or traditional threshold schemes).
 For these, a native multi-signature scheme means that what is left is one
 signature per transaction input.
 
\end_layout

\begin_layout Standard
A key aggregation scheme also lets us reduce the number of public keys per
 input to one, as a user can send coins to the aggregate of all involved
 key, rather than including them all in the script.
 This leads to smaller on-chain footprint, faster validation, and better
 privacy.
 As a result, MuSig is a good choice here.
 
\end_layout

\begin_layout Standard
Instead of creating restrictions with one signature per input, one signature
 can be used for the entire transaction.
 Key aggregation cannot be used across multiple inputs, as the public keys
 are committed to by the outputs, and those can be spent independently.
 MuSig can be used here (with key aggregation done by the verifier).
 
\end_layout

\begin_layout Standard
On a technical standing, in order to combine all the transaction inputs'
 signatures, a multi-signature scheme is not necessary, instead an aggregate
 signature scheme can be used.
 The distinction is simply that in an aggregate signature, each signer has
 their own message, instead of one message shared by all.
 
\end_layout

\begin_layout Standard
Aggregate signatures can be categorized as being:
\end_layout

\begin_layout Itemize
Interactive: Interactive aggregate signatures (IAS) require the signers
 to cooperate, while non-interactive schemes all the aggregation to be done
 by anyone
\end_layout

\begin_layout Itemize
Non-interactive: These allow the aggregation to be done by anyone
\end_layout

\begin_layout Standard
No non-interactive aggregation schemes are known that only rely on the DL
 assumption, but interactive ones are trivial to construct: where a multi-signat
ure scheme has every participant sign the concatenation of all messages.
 The paper by Blockstream, focusing on key aggregation for Schnorr Signatures
 shows that this is not always a desirable construction, and gives an IAS
 variant of BN with better properties instead.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wuille2018"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Details 
\end_layout

\begin_layout Standard

\bar under
Notation 
\end_layout

\begin_layout Itemize
\begin_inset Formula $x,x_{1,}x_{2...}$
\end_inset

are private keys with corresponding public keys 
\begin_inset Formula $X,X_{1},X_{2}...$
\end_inset

 
\begin_inset Formula $X_{i}=x_{i}G$
\end_inset

, with 
\begin_inset Formula $G$
\end_inset

 the generator
\end_layout

\begin_layout Itemize
The message being signed is 
\begin_inset Formula $m$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $H()$
\end_inset

 is a cryptographic hash function 
\end_layout

\begin_layout Standard

\bar under
Schnorr Signatures
\bar default
 
\end_layout

\begin_layout Itemize
Signatures are 
\begin_inset Formula $(R,s)=(rG,r+H(X,R,m)x)$
\end_inset

 where 
\begin_inset Formula $r$
\end_inset

is a random nonce chosen by the signer 
\end_layout

\begin_layout Itemize
Verification requires 
\begin_inset Formula $sG=R+H(X,R,m)X$
\end_inset


\end_layout

\begin_layout Standard

\bar under
Naive Schnorr multi-signatures 
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $X$
\end_inset

 the sum of the 
\begin_inset Formula $X_{i}$
\end_inset

 points
\end_layout

\begin_layout Itemize
Each signer chooses a random nonce 
\begin_inset Formula $r_{i}$
\end_inset

 and shares 
\begin_inset Formula $R_{i}=r_{i}G$
\end_inset

 with the other signers 
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $R$
\end_inset

 the sum of the 
\begin_inset Formula $R_{i}$
\end_inset

 points
\end_layout

\begin_layout Itemize
Each signer computes 
\begin_inset Formula $s_{i}=r_{i}+H(X,R,m)x_{i}$
\end_inset


\end_layout

\begin_layout Itemize
The final signature is 
\begin_inset Formula $(R,s)$
\end_inset

 where 
\begin_inset Formula $s$
\end_inset

 is the sum of the 
\begin_inset Formula $s_{i}$
\end_inset

values 
\end_layout

\begin_layout Itemize
Verification requires 
\begin_inset Formula $sG=R+H(X,R,m)X$
\end_inset

, where 
\begin_inset Formula $X$
\end_inset

 is the sum of the individual public keys
\end_layout

\begin_layout Standard
It is interesting to note that this satisfies the definition of a 
\emph on
key aggregation scheme
\emph default
, as multiple parties can jointly produce a signature that is a valid single-key
 signature for the sum of the keys.

\emph on
 
\end_layout

\begin_layout Standard
The issue arises in that this scheme is not secure.
 Consider the following scenario:
\end_layout

\begin_layout Itemize
Alice and Bob want to produce a multi-signature together.
\end_layout

\begin_layout Itemize
Alice has a key pair 
\begin_inset Formula $(x_{A},X_{A})$
\end_inset

 and Bob has 
\begin_inset Formula $(x_{B,}X_{B}).$
\end_inset

 However, nothing prevents Bob from claiming that his public key is 
\begin_inset Formula $X_{B}'=X_{B}-X_{A}.$
\end_inset

 
\end_layout

\begin_layout Itemize
If he does so, others will assume that 
\begin_inset Formula $X_{A}+X_{B}'$
\end_inset

is the aggregated key that Alice and Bob need to cooperate in order to sign
 for 
\end_layout

\begin_layout Itemize
Unfortunately, that is equal to 
\begin_inset Formula $X_{B}$
\end_inset

, thus Bob can clearly sign for this by himself 
\end_layout

\begin_layout Itemize
This is called a rogue-key attack 
\end_layout

\begin_layout Itemize
One way to avoid this is requiring that Alice and Bob prove first that they
 actually possess the private keys corresponding to their claimed public
 keys; however this is not always possible
\end_layout

\begin_layout Itemize
Ideally a scheme needs to be constructed whose security does not rely on
 out-of-band verification of the keys.
\end_layout

\begin_layout Section
Simple Schnorr Multi-Signatures with Applications to Bitcoin 
\end_layout

\begin_layout Standard
The paper describes a new Schnorr-based multi-signature scheme called MuSig,
 which is provably secure in the 
\emph on
plain public-model.
 
\emph default
This means that signers are only required to have a public key, but they
 do not have to prove knowledge of the private key corresponding to their
 public key to some certification authority or to other signers prior to
 engaging the protocol.
 
\end_layout

\begin_layout Standard
This new scheme provides improvements to Bellare and Neven (ACM-CCS 2006)
 and its variants by Bagherzandi 
\emph on
et al.
 
\emph default
(ACM-CCS 2008) and Ma 
\emph on
et al.
 
\emph default
(Des.
 Codes Cryptogr., 2010)
\emph on
 
\begin_inset Marginal
status collapsed

\begin_layout Plain Layout
Write Sections on Bagerzandi and Ma
\end_layout

\end_inset


\emph default
in two respects: 
\end_layout

\begin_layout Enumerate
It is simple and efficient, as it has the same key and signature size as
 standard Schnorr signatures; 
\end_layout

\begin_layout Enumerate
It allows 
\emph on
key aggregation
\emph default
, where the joint signature can be verified just as a standard Schnorr signature
 with respect to a single 
\begin_inset Quotes eld
\end_inset

aggregated
\begin_inset Quotes erd
\end_inset

 public key which can be computed from the individual public keys of the
 signers.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
Multi-signatures 
\end_layout

\begin_layout Standard
Introduced by Itakura and Nakamura 
\begin_inset CommandInset citation
LatexCommand cite
key "Itakura1983"
literal "false"

\end_inset

, multi-signature protocols allow a group of signers (that individually
 possess their own private/public key pair) to produce a single signature
 
\begin_inset Formula $\sigma$
\end_inset

on a message 
\begin_inset Formula $m$
\end_inset

.
 Verification of the given signature 
\begin_inset Formula $\sigma$
\end_inset

can be publicly performed given the message and the set of public keys of
 all signers.
 
\end_layout

\begin_layout Standard
A simple way to change a standard signature scheme into a multi-signature
 scheme is to have each signer produce a stand-alone signature for 
\begin_inset Formula $m$
\end_inset

 with its private key and to then concatenate all individual signatures.
 
\end_layout

\begin_layout Standard
The transformation of a standard signature scheme to a multi-signature scheme
 needs to useful and practical, thus the newly calculated multi-signature
 scheme must produce signatures where the size is independent of the number
 of signers and similar to that of the original signature scheme.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Rogue Attacks 
\end_layout

\begin_layout Standard
Rogue attacks are a significant concern when implementing multi-signature
 schemes.
 Here a subset of corrupted singers, manipulate the public keys computed
 as functions of the public keys of honest users, allowing them to easily
 produce forgeries for the set of public keys (despite them not knowing
 the associated secret keys.
 
\end_layout

\begin_layout Standard
Proposals from 
\begin_inset CommandInset citation
LatexCommand cite
key "Li1994"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Harn1994"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Horster1995"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Ohta1991"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Langford1996"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Michels1996"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Ohta1999"
literal "false"

\end_inset

 were thus undone before a formal model was put forward along with a provably
 secure scheme from Micali, Ohta, and Reyzin.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Micali2001"
literal "false"

\end_inset

Unfortunately, despite being provably secure this scheme is costly and an
 impractical interactive key generation protocol.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
A means of generically preventing rogue-key attacks is to make it mandatory
 for users to prove knowledge (or possession 
\begin_inset CommandInset citation
LatexCommand cite
key "Ristenpart2007"
literal "false"

\end_inset

) of the secret key during public key registration with a certification
 authority.
 Certification authority is a setting known as the knowledge of secret key
 (KOSK) assumption.
 The pairing-based multi-signature schemes by Boldyreva 
\begin_inset CommandInset citation
LatexCommand cite
key "Boldyreva2003"
literal "false"

\end_inset

 and Lu 
\emph on
et al
\emph default
.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Lu2006"
literal "false"

\end_inset

 rely on the KOSK assumption in order to maintain security.
 However, this as can be seen from 
\begin_inset CommandInset citation
LatexCommand cite
key "Bellare2006"
literal "false"

\end_inset

and 
\begin_inset CommandInset citation
LatexCommand cite
key "Ristenpart2007"
literal "false"

\end_inset

 this assumption is problematic.
 
\begin_inset Marginal
status collapsed

\begin_layout Plain Layout
Should Bellare and Neven reference be included in this statement
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As it stands, the Bellare and Neven 
\begin_inset CommandInset citation
LatexCommand cite
key "Bellare2006"
literal "false"

\end_inset

 provides the most practical multi-signature scheme, based on the Schnorr
 signature scheme, which is provably secure that does not contain any assumption
 on the key setup.
 Since the only requirement of this scheme is that each potential signer
 has a public key, this setting is referred to as the 
\emph on
plain-key model.
 
\end_layout

\begin_layout Subsubsection
Schnorr Signature Scheme 
\end_layout

\begin_layout Standard
The Schnorr signature scheme uses:
\begin_inset CommandInset citation
LatexCommand cite
key "Schnorr1991"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
A cyclic group 
\begin_inset Formula $G$
\end_inset

 of prime order 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Itemize
A generator 
\begin_inset Formula $g$
\end_inset

of 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Itemize
A hash function 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Itemize
A private/public key pair is a pair 
\begin_inset Formula $(x,X)$
\end_inset


\begin_inset Formula $\epsilon\{0,...,p-1\}$
\end_inset


\begin_inset Formula $\mathsf{x}$
\end_inset


\begin_inset Formula $G$
\end_inset

 where 
\begin_inset Formula $X=g^{x}$
\end_inset


\end_layout

\begin_layout Itemize
To sign a message 
\begin_inset Formula $m$
\end_inset

, the signer draws a random integer 
\begin_inset Formula $r$
\end_inset

in 
\begin_inset Formula $Z_{p},$
\end_inset

 computes 
\begin_inset Formula $R=g^{r}$
\end_inset

, 
\begin_inset Formula $c=H(X,R,m)$
\end_inset

, and 
\begin_inset Formula $s=r+cx$
\end_inset


\end_layout

\begin_layout Itemize
The signature is the pair 
\begin_inset Formula $(R,s)$
\end_inset

 , and its validity can be checked by verifying whether 
\begin_inset Formula $g^{s}=RX^{c}$
\end_inset


\end_layout

\begin_layout Standard
The above described is referred to as the so-called 
\begin_inset Quotes eld
\end_inset

key-prefixed
\begin_inset Quotes erd
\end_inset

 variant of the scheme, which sees the public key hashed together with 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Bernstein2012"
literal "false"

\end_inset

.
 This variant was thought to have a better multi-user security bound than
 the classic variant 
\begin_inset CommandInset citation
LatexCommand cite
key "Bernstein2015"
literal "false"

\end_inset

, however in 
\begin_inset CommandInset citation
LatexCommand cite
key "Kiltz2016"
literal "false"

\end_inset

 the key-prefixing was seen as unnecessary to enable good multi-user security
 for Schnorr signatures.
 
\end_layout

\begin_layout Standard
For the development of the new Schnorr-based multi-signature scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset

, key-prefixing seemed a requirement for the security proof to go through,
 despite not knowing the form of an attack.
 The rationale also follows the process in reality, as messages signed in
 Bitcoin always indirectly commits to the public key.
 
\end_layout

\begin_layout Subsubsection
Design of a Schnorr multi-signature scheme
\end_layout

\begin_layout Standard
The naive way to design a Schnorr multi-signature scheme would be as follows:
\end_layout

\begin_layout Itemize
A group of 
\begin_inset Formula $n$
\end_inset

signers want to cosign a message 
\begin_inset Formula $m$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Let 
\begin_inset Formula $L=\{X_{1}=g^{x_{1}},...,X_{n}=g^{x_{n}}\}$
\end_inset

 be the multi-set of all public keys 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
No constraints are imposed on the key setup, the adversary thus can choose
 corrupted public keys at random, hence the same public key can appear more
 than once in 
\begin_inset Formula $L$
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Each cosigner randomly generates and communicates to others a share 
\begin_inset Formula $R_{i=}$
\end_inset


\begin_inset Formula $g^{r_{i}}$
\end_inset


\end_layout

\begin_layout Itemize
Each of the cosigners them computes 
\begin_inset Formula $R=$
\end_inset


\begin_inset Formula $\Pi_{_{i=1}}^{n}$
\end_inset


\begin_inset Formula $R_{i}$
\end_inset

, 
\begin_inset Formula $c=H(\tilde{X},R,m)$
\end_inset

 
\end_layout

\begin_layout Itemize
Where 
\begin_inset Formula $\tilde{X}=\Pi_{i=1}^{n}X_{i}$
\end_inset

 is the product of individual public keys, and a partial signature 
\begin_inset Formula $s_{i}=r_{i}+cx_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Partial signatures are then combined into a single signature 
\begin_inset Formula $(R,s)$
\end_inset

 where 
\begin_inset Formula $s=\Sigma_{i=1}^{n}si$
\end_inset

 mod 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Itemize
The validity of a signature 
\begin_inset Formula $(R,s)$
\end_inset

 on message 
\begin_inset Formula $m$
\end_inset

 for public keys 
\begin_inset Formula $\{X_{1},...X_{n}\},$
\end_inset

is equivalent to 
\begin_inset Formula $g^{s}=R\tilde{X}^{c}$
\end_inset

 where 
\begin_inset Formula $\tilde{X}=\Pi_{i=1}^{n}X_{i}$
\end_inset

 and 
\begin_inset Formula $c=H(\tilde{X},R,m)$
\end_inset


\end_layout

\begin_layout Itemize
Note that this is exactly the verification equation for a traditional key-prefix
ed Schnorr signature with respect to public key 
\begin_inset Formula $\tilde{X}$
\end_inset

, a property termed 
\emph on
key aggregation 
\end_layout

\end_deeper
\begin_layout Standard
However, as mentioned above, 
\begin_inset CommandInset citation
LatexCommand cite
key "Horster1995"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Langford1996"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Michels1996"
literal "false"

\end_inset

 and
\begin_inset CommandInset citation
LatexCommand cite
key "Micali2001"
literal "false"

\end_inset

 these protocols are vulnerable to a rogue-key attack where a corrupted
 signer sets its public key to 
\begin_inset Formula $X_{1}=g^{x_{1}}(\Pi_{i=2}^{n}X_{i})^{-1}$
\end_inset

, allowing the signer to produce signatures for public keys 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\{X_{1},...X_{n}\}$
\end_inset

 by themself.
\end_layout

\begin_layout Subsubsection
Micali-Ohta-Reyzin Multi-signature scheme 
\end_layout

\begin_layout Standard
The Micali-Ohta-Reyzin multi-signature scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "Micali2001"
literal "false"

\end_inset

solves the rogue-key attack using a sophisticated interactive key generation
 protocol.
 
\end_layout

\begin_layout Subsubsection
Bellare and Neven 
\end_layout

\begin_layout Standard
Bellare-Neven (BN) 
\begin_inset CommandInset citation
LatexCommand cite
key "Bellare2006"
literal "false"

\end_inset

proceeded differently in order to avoid any key setup.
 It is a more widely known plain public-key multi-signature scheme, that
 does not support key aggregation.
 It is possible to use BN multi-signatures where the individual keys are
 MuSig aggregates.
 BN multi-signature scheme is secure without such assumptions.
 Below are details:
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $L=H(X_{1,}X_{2...})$
\end_inset


\end_layout

\begin_layout Itemize
Each signer chooses a random nonce 
\begin_inset Formula $r_{i}$
\end_inset

 and shares 
\begin_inset Formula $R$
\end_inset


\begin_inset Formula $_{i}=r_{i}G$
\end_inset

 with the other signers
\end_layout

\begin_layout Itemize
Call R the sum of the 
\begin_inset Formula $R_{i}$
\end_inset

 points 
\end_layout

\begin_layout Itemize
Each signer computes 
\begin_inset Formula $s_{i}=r_{i}+H(L,X_{i,}R,m)x_{i}$
\end_inset


\end_layout

\begin_layout Itemize
The final signature is 
\begin_inset Formula $(R,s)$
\end_inset

 where 
\begin_inset Formula $s$
\end_inset

is the sum of the 
\begin_inset Formula $s_{i}$
\end_inset

 values 
\end_layout

\begin_layout Itemize
Verification requires 
\begin_inset Formula $sG=R+H(L,X_{1,}R,m)X_{2}+...$
\end_inset


\end_layout

\begin_layout Standard
Technically, BN has a pre-commit round, where the signers initially reveal
 
\begin_inset Formula $H(R_{i})$
\end_inset

to each other, prior to revealing the 
\begin_inset Formula $R_{i}$
\end_inset

 points themselves.
 This step is a requirement in order to prove security under the DL assumption,
 but it can be dismisses if instead the OMDL assumption is accepted.
 
\end_layout

\begin_layout Standard
Furthermore, when an IAS is desired (where each signer has their own message),
 
\begin_inset Formula $L=H((X_{1},m_{1)},(X_{2},m_{2}),...)$
\end_inset

 and 
\begin_inset Formula $s_{i}=r_{i}+H(L,R,i)x_{i}$
\end_inset

 is used for signing (and analogous for verification).
 
\end_layout

\begin_layout Standard
The resulting signature does not satisfy the normal Schnorr equation anymore,
 nor any other equation that can be written as a function of a combination
 of the public keys; the key aggregation property is lost in order to gain
 security in the plain public-key model.
 
\end_layout

\begin_layout Standard
This is where MuSig comes in.
 It recovers the 
\emph on
key aggregation property without losing security:
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $L=H(X_{1},X_{2}...)$
\end_inset


\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $X$
\end_inset

 the sum of all 
\begin_inset Formula $H(L,X_{i})X_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Each signer chooses a random nonce 
\begin_inset Formula $r_{i},$
\end_inset

 and shares 
\begin_inset Formula $R$
\end_inset


\begin_inset Formula $_{i}=r_{i}G$
\end_inset

 with the other signers 
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $R$
\end_inset

 the sum of the 
\begin_inset Formula $R$
\end_inset


\begin_inset Formula $_{i}$
\end_inset

 points 
\end_layout

\begin_layout Itemize
Each signer computes 
\begin_inset Formula $s_{i}=r_{i}+H(X,R,m)H(L,X_{i})x_{i}$
\end_inset


\end_layout

\begin_layout Itemize
The final signature is 
\begin_inset Formula $(R,s)$
\end_inset

 where 
\begin_inset Formula $s$
\end_inset

is the sum of the 
\begin_inset Formula $s_{i}$
\end_inset

 values 
\end_layout

\begin_layout Itemize
Verification again satisfies 
\begin_inset Formula $sG=R+H(X,R,m)X$
\end_inset


\end_layout

\begin_layout Standard
So what was needed was to define 
\begin_inset Formula $X$
\end_inset

 not as a simple sum of the individual public keys 
\begin_inset Formula $X_{i},$
\end_inset

but as a sum of multiples of those keys, where the multiplication factor
 depends on a hash of all participating keys.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wuille2018"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Their main idea is to have each cosigner use a distinct 
\begin_inset Quotes eld
\end_inset

challenge
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $c_{i}$
\end_inset

when computing their partial signature 
\begin_inset Formula $s_{i}=r_{i}+c_{i}x_{i},$
\end_inset

defined as 
\begin_inset Formula $c_{i}=H(<L>X_{i},R,m),$
\end_inset

where as before 
\end_layout

\begin_layout Standard
Bellare and Neven showed that this yields a multi-signature scheme provably
 secure in the 
\emph on
plain public-key 
\emph default
model under the Discrete Logarithm assumptions, modeling 
\begin_inset Formula $H$
\end_inset

and 
\begin_inset Formula $H'$
\end_inset

as random oracles.
 However, this scheme does not allow key aggregation anymore since the entire
 list of public keys is required for verification.
 
\end_layout

\begin_layout Subsubsection
The new scheme
\end_layout

\begin_layout Standard
The new proposed Schnorr-based multi-signature scheme can be seen as a variant
 of the BN scheme, allowing key aggregation in the 
\emph on
plain public-key model.
 
\emph default
This scheme consists of three rounds, the first two being exactly the same
 as in BN.
 Challenges 
\begin_inset Formula $c_{i}$
\end_inset

 are changed from 
\begin_inset Formula $c_{i}=H(<L>X_{i},R,m)$
\end_inset

 to 
\begin_inset Formula $c_{i}=H_{agg}(<L>X_{i}).H_{sig}(\tilde{X,}R,m)$
\end_inset

 , where 
\begin_inset Formula $\tilde{X}$
\end_inset

is the so-called aggregated public key corresponding to the multi-set of
 public keys 
\begin_inset Formula $L=\{X_{1},...X_{n}\},$
\end_inset

 defined as 
\begin_inset Formula $\tilde{X}=\stackrel[i=1]{n}{\Pi}X_{i}^{a_{i}c}=R\tilde{X}^{c}$
\end_inset

 where 
\begin_inset Formula $c=H_{sig}(\tilde{X},R,m).$
\end_inset


\end_layout

\begin_layout Standard
Basically , the key aggregation property has been recovered and can now
 be enjoyed by the naive scheme, which respect to a more complex aggregation
 key 
\begin_inset Formula $\tilde{X}=\stackrel[i=1]{n}{\Pi}X_{i}^{a_{i}c}$
\end_inset

.
 
\begin_inset Formula $c=H_{sig}(<L>,R,m)$
\end_inset

 yields a secure scheme, however does not allow key aggregation since verificati
on is impossible without knowing all the individual singer keys.
 
\end_layout

\begin_layout Subsubsection
The benefits of key aggregation 
\end_layout

\begin_layout Itemize
If a group of 
\begin_inset Formula $n$
\end_inset

signers want to authorize which all of them agree, but do not necessarily
 wish to reveal their individual public keys 
\end_layout

\begin_layout Itemize
They can privately compute the aggregated key 
\begin_inset Formula $\tilde{X}$
\end_inset

 corresponding to their multi-set of public keys and publish it as an ordinary
 (non-aggregated) key.
 
\end_layout

\begin_layout Itemize
Signers are ensured that all of them will need to cooperate to produce a
 signature which is valid under 
\begin_inset Formula $\tilde{X}$
\end_inset

, whereas verifiers will not even learn that 
\begin_inset Formula $\tilde{X}$
\end_inset

is in fact an aggregated key.
 
\end_layout

\begin_layout Itemize
Moreover, 
\begin_inset Formula $\tilde{X}$
\end_inset

can be computed by a third party just from the list of public keys, without
 interacting with the signers.
\end_layout

\begin_layout Itemize
This property will rpove instrumental for obtaining a more compact and privacy-p
reserving variant of so-called 
\emph on
n-
\emph default
of-
\emph on
n 
\emph default
multi-signature transactions in Bitcoin.
 
\end_layout

\begin_layout Standard
Two variants of the BN multi-signature scheme have been previously proposed.
 
\end_layout

\begin_layout Subsubsection
The Bagherzandi 
\emph on
et al.
 
\emph default
Scheme
\end_layout

\begin_layout Standard
Bagherzandi 
\emph on
et al.
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Bagherzandi2008"
literal "false"

\end_inset

 reduced the number of rounds from three to two using an homomorphic commitment
 scheme.
 Unfortunatel, this increases the signature size and the computational cost
 of signing and verification.
 
\end_layout

\begin_layout Subsubsection
The Ma 
\emph on
et al.

\emph default
 Scheme 
\end_layout

\begin_layout Standard
Ma 
\emph on
et al.
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Ma2010"
literal "false"

\end_inset

proposed a variation based on Okamoto's signature scheme
\begin_inset CommandInset citation
LatexCommand cite
key "Okamoto1992"
literal "false"

\end_inset

, which involved the 
\begin_inset Quotes eld
\end_inset

double hashing
\begin_inset Quotes erd
\end_inset

 technique, which sees the reduction of the signature size compared to 
\begin_inset CommandInset citation
LatexCommand cite
key "Bagherzandi2008"
literal "false"

\end_inset

while using only two rounds.
 
\end_layout

\begin_layout Standard
However, neither of these two variants allow for key aggregation.
 
\end_layout

\begin_layout Standard
Multi-signature schemes supporting key aggreagation are easier to come by
 in the KOSK model.
 In particular, Syta 
\emph on
et al.

\emph default
 proposed
\emph on
 
\emph default
the CoSi scheme which can be seen as the naive Schnorr multi-signature scheme
 described earlier where the cosiners are organsied in a tree structure
 for fast signature generation.
 
\end_layout

\begin_layout Section
Interactive Aggregate Signatures
\end_layout

\begin_layout Standard
In some situations, it may be useful to allow each participant to sign a
 different message rather than a single common one.
 An interactive aggregate signature (IAS) is one where each signer has its
 own message 
\emph on

\begin_inset Formula $m_{i}$
\end_inset

 
\emph default
to sign, and the joint signature proves that the 
\begin_inset Formula $i$
\end_inset

-th signer has signed 
\begin_inset Formula $m_{i}$
\end_inset

 .
 These schemes are more general than multi-signature schemes, however they
 are less flexible than non-interactive aggregate signatures 
\begin_inset CommandInset citation
LatexCommand cite
key "Boneh2003,Bellare2007"
literal "false"

\end_inset

 and sequential aggreagate signatures [LMRSO4].
 
\end_layout

\begin_layout Standard
According to Bellare and Neven [BN06], they suggested a generic way to turn
 any multi-signature scheme into an IAS scheme by the signer running the
 multi-signature protocol using as message the tuple of all public keys/message
 pairs involced in the IAS protocol.
 
\end_layout

\begin_layout Standard
For BN's scheme and the scheme of the Blockstream signature scheme, this
 does not increase the number of communication rounds as messages can be
 sent together with shares 
\begin_inset Formula $R_{i}$
\end_inset

.
 
\end_layout

\begin_layout Standard
However, the problem arise with the generic construction in the 
\emph on
plain public-key model.
 
\emph default
We will now take a closer look at this transformation and show that is subtly
 fails to provide the strongest security guarantees in the 
\emph on
plain public key model.
 
\end_layout

\begin_layout Subsection
Syntax and Security Model 
\end_layout

\begin_layout Standard
The syntax is adapted as follows.
 An IAS scheme 
\emph on
II
\emph default
 is a triple of algorithms 
\begin_inset Formula $\mathsf{(\mathsf{KeyGen,Sign,}Ver).}$
\end_inset

 The randomization key generation algorithm takes no input and returns a
 private/public key pair 
\begin_inset Formula $\mathsf{(sk,pk)}\leftarrow_{\$}\mathsf{KeyGen()}.$
\end_inset

 The signature algorithm 
\begin_inset Formula $\mathsf{Sign}$
\end_inset

 is run by each participant on input its key pair 
\begin_inset Formula $\mathsf{(sk,pk)}$
\end_inset

, a message 
\begin_inset Formula $m$
\end_inset

, and a set of public key/message pairs for other cosigners 
\begin_inset Formula $S'=\left\{ (pk_{1}^{'},m_{1}^{'}),...(pk_{n-1}^{'},m_{n-1}^{'})\right\} $
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(\mathsf{pk,}m)$
\end_inset


\begin_inset Formula $\notin S'$
\end_inset

; it returns a signature 
\begin_inset Formula $\sigma$
\end_inset

for the set of public key/message pairs 
\begin_inset Formula $S=S'\cup\{(\mathsf{pk,}m)\}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $S$
\end_inset

 is a set, i.e., no public key/message pair repeats, even though the same
 public key might appear mulitple times.
 This is without loss of generality since any repeated public key/message
 pair in 
\begin_inset Formula $S$
\end_inset

 can be deleted by the signature/verification algorithm.
\end_layout

\end_inset

 The determinisitic verification algorithm 
\begin_inset Formula $\mathsf{Ver}$
\end_inset

 takes as input a set of public key/message pairs 
\begin_inset Formula $S=\{(\mathsf{pk_{1},}m_{1}),...,(\mathsf{pk_{n},}m_{n})\}$
\end_inset

 and a signature 
\begin_inset Formula $\sigma$
\end_inset

, and returns 1 if the signature is valid for 
\begin_inset Formula $S$
\end_inset

 and 0 otherwise.
 
\end_layout

\begin_layout Standard
As another means, one can specify the signature algorithm to take as input
 a key pair 
\end_layout

\begin_layout Subsection
Revisions 
\end_layout

\begin_layout Standard
A previous version of this paper, dated January 15, 2918, proposed a 2-round
 vaiant of 
\begin_inset Formula $\mathsf{MuSig}$
\end_inset

, where the intital commitment round is omitted claiming a security proof
 unsre the One More Discrete Logarithm (OMDL) assumptions [BP02][BNPS03].
 However, a flaw in the secuirty proof was discovered by Drijvers 
\emph on
et al.
 
\emph default
[DEFN18], hwo also showed through a meta-reduction that this scheme cannot
 be proved secure using an algebraic black box reduction inder the DL or
 OMDL assumption (assuming the OMDL problem is hard).
 
\end_layout

\begin_layout Standard
In more details, observe that in the 2-round variant of 
\begin_inset Formula $\mathsf{MuSig}$
\end_inset

, an adversary (controlling public keys 
\begin_inset Formula $X_{2},...,X_{n})$
\end_inset

 can impose the value of 
\begin_inset Formula $R=\Pi_{i=1}^{n}R_{i}$
\end_inset

 used in signature protocols since he can choose 
\begin_inset Formula $R_{2},...,R_{n}$
\end_inset

after having recived 
\begin_inset Formula $R_{1}$
\end_inset

from the honest signer (contolling public key 
\begin_inset Formula $X_{1}=g^{x_{1}}$
\end_inset

).
 This forbids to use the textbook way of simulating the honest signer in
 the Random Oracle model without knowing 
\begin_inset Formula $x_{1}$
\end_inset

 by randomly drawing 
\begin_inset Formula $s_{1}$
\end_inset

 and 
\begin_inset Formula $c$
\end_inset

, computing 
\end_layout

\begin_layout Standard
There is no attach currently known against the 2-rounf variant of MuSig
 and that it might be secure although thais is not provable under standard
 assumptions from exisiting techniques.
 
\end_layout

\begin_layout Section
The Discrete Logarithm Problem 
\end_layout

\begin_layout Standard
Definition 1 (DL problem)
\end_layout

\begin_layout Itemize
Let 
\begin_inset Formula $\mathbb{G}$
\end_inset

 
\begin_inset Formula $,p,g$
\end_inset

 be group parameters- it is fixed, but the bit length 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

can be regarded as a security parameter if neccesary.
 
\end_layout

\begin_layout Itemize
An algorithm 
\begin_inset Formula $\mathcal{A}$
\end_inset

 is said to 
\begin_inset Formula $(t,\varepsilon solve$
\end_inset

the DL problem with with respect to 
\begin_inset Formula $\mathbb{G},p,g$
\end_inset

 if on input a random gorup element 
\begin_inset Formula $X$
\end_inset

, it runs in time at most 
\begin_inset Formula $t$
\end_inset

 and returns 
\begin_inset Formula $x\in\{0,...,p-1\}$
\end_inset

 such that 
\end_layout

\begin_layout Section
Elliptic Curve Digital Signature Algorithm 
\end_layout

\begin_layout Standard
Currently in Bitcoin ECDSA is implemented.
 To sign a message 
\begin_inset Formula $m$
\end_inset

 fwe hash it and treat this hash as a number: 
\begin_inset Formula $z=hash(m)$
\end_inset

.
 We also need a random or random-looking number 
\begin_inset Formula $k$
\end_inset

.
 We prefer not to trusut random number generators (too many failures and
 vulnerabilities are realted to bad random number generators) so we usually
 use 
\bar under
RFC6979
\bar default
 to calulate deterministic 
\begin_inset Formula $k$
\end_inset

 absed on our secret and teh message we are signing.
 
\end_layout

\begin_layout Standard
Using a private key 
\begin_inset Formula $pk$
\end_inset

 we can generate a signature for message 
\begin_inset Formula $m$
\end_inset

 consisting of two numbers: 
\begin_inset Formula $r$
\end_inset

(
\begin_inset Formula $x$
\end_inset

coordinate of the random point 
\begin_inset Formula $R=kG$
\end_inset

 and 
\begin_inset Formula $s=(z+rpk)/k$
\end_inset

.
 Then, using our public key 
\begin_inset Formula $P=pkG$
\end_inset

 anyone can verify our signature by checking that point 
\begin_inset Formula $(\frac{z}{s})G+(\frac{r}{s})P$
\end_inset

 has 
\begin_inset Formula $x$
\end_inset

coordinate equal to 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\begin_layout Standard
Insert Image 
\end_layout

\begin_layout Standard
This algorithm is very common, hoever it can be improved.
 Firstly, signature verification includes inversion 
\begin_inset Formula $(1/s)$
\end_inset

 snf two points multiplications an these operations are very computationally
 heavy.
 In Bitocin every node has to verify all the tansactions.
 This means that when you broadcast a transastion, thousands of computers
 will have to verify yoru signature.
 Making verification procress simpler will be very beneficial even if signing
 is more difficult.
 
\end_layout

\begin_layout Standard
Secondly, every node has to verify every signature individually.
 In the case of m-of-n multisig transaction node may even have to verify
 the same signautre several times.
 For example, transaction of 7-of-11 multisig input will contrain 7 signatues
 and require from 7 to 11 signaute verifications on every node in teh network.
 Also such transaction will take a huge amount of space in teh block and
 you will have to pay large fees for that.
 
\end_layout

\begin_layout Section
Schnorr signatures 
\end_layout

\begin_layout Standard
Schnorr signatures are generated slightly differently.
 Instead of two scalars 
\begin_inset Formula $(r,s)$
\end_inset

we use a point 
\begin_inset Formula $R$
\end_inset

 and a scalar .
 Like ECDSA, 
\begin_inset Formula $R$
\end_inset

 is considered a random point on the elliptic curve 
\begin_inset Formula $(R=kG)$
\end_inset

.
 Second part of the signaute is calculated slightly differently: 
\begin_inset Formula $s=k+hash(P,R,m)pk$
\end_inset

.
 Here 
\begin_inset Formula $pk$
\end_inset

 is your private key, 
\begin_inset Formula $P=pkG$
\end_inset

 is yoru public key, 
\begin_inset Formula $m$
\end_inset

 is the message.
 Then onc can verify this signatuare by checking that 
\begin_inset Formula $sG=R+hash(P,R,m)P$
\end_inset


\end_layout

\begin_layout Standard
Insert image: Visualisation of the Schnorr signature verification 
\end_layout

\begin_layout Standard
This equation is linear, so equations can be added and sutracted with each
 other and still stay valid.
 This leads to a nice feature of Schnorr signatures.
\end_layout

\begin_layout Subsection
Batch Validation 
\end_layout

\begin_layout Standard
To verify a block in Bitcoin blockchain we need to make sure that all signatures
 in the block are valid.
 If one of them is not valid we don't care which one- we just reject eh
 whole block and that's it.
 
\end_layout

\begin_layout Standard
With ECDSA every signature has to be verified separately.
 Meaning that if we have 1000 signatures in the block we will need to compute
 1000 inversions and 2000 point multiplication.
 In total approximately 3000 heavy operations.
\end_layout

\begin_layout Standard
With Schnorr signatures we can add up all the signature verification equatiosn
 and save some computational power.
 In total for a block with 1000 transactions we need to verify that:
\end_layout

\begin_layout Standard

\emph on
(s1+s2+...+s1000)G=(R1+...+R1000)+(hash(P1,R1,m1)P1+hash(P2,R2,m2)P2+...+hash(P1000,R1000
, m1000)P1000 
\end_layout

\begin_layout Standard
Here we have a bunch of point additions (almost free in sense of computational
 power) and 1001 point mulitplication.
 This is already a factor of 3 improvement- we meed to compute roughyl one
 heavy operation per signature.
 
\end_layout

\begin_layout Standard
Insert image: Batch validation of two signatures.
 As verification equation is linear the sum of several equations is valid
 as soon as all signatures are valid.
 We save some computational power as scalare and point additions are much
 easier than point muliplication.
 
\end_layout

\begin_layout Subsection
Key aggregation 
\end_layout

\begin_layout Standard
There is a need to keep one's bitcoin safe, so we might want to use at least
 two different private keys to control bitcoins.
 Once we will use on a laptop or a phone and another one- on a hardware
 wallet/cold wallet.
 So when one of them is compromised we still have control over our bitcoins.
 
\end_layout

\begin_layout Standard
Currently it is implemented via 2-of-2 multisg script.
 This requires two separate signatures to be included in the transaction.
\end_layout

\begin_layout Standard
With Schnorr signatures we can use a pair of private keys 
\begin_inset Formula $(pk1,pk2)$
\end_inset

 and generate a shared signature corresponding to a shared public key 
\begin_inset Formula $P=P1+P2=pk1G+pk2G$
\end_inset

.
 To generate this signature we need to choose a random number on every device
 
\begin_inset Formula $(k1,k2)$
\end_inset

, generate a random point 
\begin_inset Formula $Ri=kiG$
\end_inset

, add them up to calcaulate a common 
\begin_inset Formula $hash(P,R1+R2,m)$
\end_inset

 and then get 
\begin_inset Formula $s1$
\end_inset

 and 
\begin_inset Formula $s2$
\end_inset

 from every device 
\begin_inset Formula $(si=ki+hash(P,R,m)pki)$
\end_inset

.
 Then we can add up these signatures and use a pair 
\begin_inset Formula $(R,s)=(R1+R2,s1+s2)$
\end_inset

as our signature for shared public key 
\begin_inset Formula $P.$
\end_inset

 Everyone else won't be able to say if it is an aggregated signature or
 
\end_layout

\begin_layout Subsection
Merkle Multi-signatures
\end_layout

\begin_layout Standard
MuSig and key aggregation require all signers to sign a transation.
 What happens if you want to make a 2-of-3 multisig? Can we use signature
 aggregation or will we have to use our usual 
\begin_inset ERT
status open

\begin_layout Plain Layout

OP_CHECKMULTISIG
\end_layout

\end_inset

 and separate signatures?
\end_layout

\begin_layout Standard
it is possible, but with a small change in the protocol.
 A new op-code similar to 
\begin_inset ERT
status open

\begin_layout Plain Layout

OP_CHECKMULTISIG
\end_layout

\end_inset

 can be developed that checks if aggregated signature corresponds to a particula
r item in teh Merkle tree of public keys.
 
\end_layout

\begin_layout Standard
For example, if we use a 2-of-3 multisig with public keys 
\begin_inset Formula $P1$
\end_inset

, 
\begin_inset Formula $P2$
\end_inset

 and 
\begin_inset Formula $P3$
\end_inset

, then we need to construct a Merkle tree of aggregated public keys for
 all combinations we can use: 
\begin_inset Formula $(P1,P2)$
\end_inset

, 
\begin_inset Formula $(P2,P3)$
\end_inset

, 
\begin_inset Formula $(P1,P3)$
\end_inset

 and put the root in the locking script.
 To spend bitcoins we provide a signature and a proof that our public keys
 is in the tree.
 For 2-of-3 multisig there are only 3 elements in the tree and the proof
 will consist fo two hashes-the one we want to use and its neighbour.
 For a 7-of-11 multisig there will be already 11!/7!/4!=300 possible key
 combinations and the proof will require 8 elements.
 In general the number of elements in the proof scels almost linear with
 the number of keys in multisig (its 
\begin_inset Formula $log2(n!m!/(n-m)!).$
\end_inset


\end_layout

\begin_layout Standard
But with the Merkle tree of public keys we are not limited to m-of-n multisigs.
 We can make a tree with any public keys we want.
 For example , if we have a laptop, a phone, a hardware wallet and a recovery
 seed, we can construct a structure that would allow us to spend bitcoins
 with a laptop and a hardware 
\end_layout

\begin_layout Section
Applications to Bitcoin
\end_layout

\begin_layout Standard
Each input ontains a signature of a modified version of the transaction
 to be validated with its referened output's key.
 In fact some outputs even require multiple signatures to be spent.
 Transactions spending such an output are often referred to as 
\emph on
m
\emph default
-of-
\emph on
n 
\emph default
multi-signature transactions [And11], and the current implementation correspondi
ng to the triviail way of building a multi-signature scheme by concatenating
 individual signatures.
 Additionally, a threshold policy can be enforced where only 
\begin_inset Formula $m$
\end_inset

 valid signatues out of the 
\begin_inset Formula $n$
\end_inset

 possible ones are needed to redeem the transaction (again this is the most
 straightforward way to turn a multi-signature scheme into some kind of
 basic threshold signature scheme).
\end_layout

\begin_layout Standard
Today Bitcoin uses ECDSA signatures [ANS05][NIS13] over the 
\begin_inset Formula $\mathsf{secp256k1}$
\end_inset

 curve [SEC10] to authenticate transactions.
 As Bitcoin nodes fully verify all transactions, signature size and verification
 time are important design considerationsm while signing time is much less
 so.
 Besiges, signatures account for a large part of the size of Bitcoin transaction
s.
 Because of this, using multi-signatures seems appealing.
 However, des
\begin_inset Formula $ $
\end_inset

igning multiparty ECDSA signature schemes is notably cumbersome [MR01][GGN16][Li
n17]due to the modular inversion involced in signing, and moving to Schnorr
 signatures would definitely help deploy compact multi-signatures.
 While several multi-signature schemes could off an improvement over the
 currently avaiable method, two properties increas the possible impact:
\end_layout

\begin_layout Itemize
The availability of key aggregatio nremoves the need for verifiers to see
 all the involved key, improving bandwidth, privacy, and validation cost
\end_layout

\begin_layout Itemize
Security under the 
\emph on
plain public-key model 
\emph default
enables multi-signatures across multiple inputs of a transaction, where
 the choice of signers cannot be committed to in advance.
 This greatly increases the number of situatiosn in which mulit-signatures
 are beneficial.
\end_layout

\begin_layout Subsection
Introduction 
\end_layout

\begin_layout Standard
Bitcoin contains every transaction since the system's inception, resulting
 in a final state, the set of unspent coins.
 Each unspent coin has an associated value (expressed as a mulitple of the
 currency unit, 
\begin_inset Formula $10^{-8}$
\end_inset

 bitcoin) and a programmable public key of the owner.
 Every transaction consumes one or more coins, proviging a signature for
 each to authorize its spending, and creates one ot more new coins, with
 a total value not larger than the value of the consumeed coins.
 
\end_layout

\begin_layout Standard
Bitcoins uses a programmable generalisation of a digitial signautre scheme.
 Instead of a public key, a predicate that determines spendability is included
 in every output (implemented in a concise programming language, called
 
\emph on
Bitcoin Script).
 
\emph default
When spending, instead of a signautrem, a witness that satisfies the predicate
 is provided.
 In practice, most output predicates effectively corresond to a single ECDSA
 verification.
 This is also how Bitcoin supports a naive version of multi-signatures with
 a threshold policy: coins can be assigned a prdicated that requires valid
 signatures for multiple public keys.
 Several use cases for the exist, including low-trust escrow services [GBGN17]
 and split-device security.
 While using thOPe predicate language to implement multi-signautes is very
 flexible, it is inefficient in terms of size, computational cost, and privacy.
 
\end_layout

\begin_layout Standard
As a global consensus system, kept in check by the ability for everyt participan
t to validate all updates to the ledger, the size of signatures and predicates,
 and teh computational cost for verifying them are the primary limiting
 factors for its scalability.
 The computational requiremnets for signing, or the communication overhead
 between different signers are far less constrained.
 Bitcon does not have any central trusted party, so it is not generally
 possible to introduce new cryptographic shcemes that requrie a trrustes
 setup.
 Finally, to function as a currency, a hgih degree of fungibility and privacy
 is desirable.
 Among other thinfs, this means that ideally the predictes of coins fo not
 lead information about the owner.
 In particilat, if several styles of predicates are in use, the choise may
 reveal what software or service is being used to manage it.
 
\end_layout

\begin_layout Subsection
Native Multi-Signature Support 
\end_layout

\begin_layout Standard
An obvious improvement is to replace the need for implementating 
\emph on
n-
\emph default
of-
\emph on
n 
\emph default
multi-signautes in an ad-hoc fashion with a constant-size mulit-signature
 primitive like Bellare-Neven, While this is on itself an improvemtn in
 terms of size, it still requires the prediccate itself-whose size also
 matters- to contain all of the signers' public keys.
 Key aggregation improves upon this further, as a single-key predicate can
 be used instead which is both smaller and has lower computational cost
 for verification.
 It also improves provacy, as the participant keys and their count remain
 private to the signers.
 
\end_layout

\begin_layout Standard
When generalizing to the 
\begin_inset Formula $m\mathcal{}$
\end_inset

-of-
\begin_inset Formula $n$
\end_inset

scenario, several options exist.
 One is to forego key aggregation, and still include all potential signer
 keys in the predicates while still only producing a single singature for
 teh chosen combination of keys.
 Alternatvely, a Merkle tree [Mer87] where the leaves are permitted combinations
 of keys (in aggregated form) can be employed.
 The predicate in this case would take as input an aggregated public key,
 a signature with it, and a proof.
 Its validity would depend on the signature being valid wiht hte provided
 key, and the proof estabishing that the key is in fact one the leaves of
 the Merkle tree, identified by its root hash.
 This approach is very generic, as it works for any subset of combinations
 of keys, and as a result has very good privacy as the exact licy is not
 visible from the proof.
 It is only feasible however when the total number of combinations is tractable.
 
\end_layout

\begin_layout Standard
Some key aggregation schemes that do not protect against rogue-key attacks
 can be used instead in the above cases, under the assumption that the sender
 is given a proof of knowledge/possession for the receivers' private keys.
 However, these schemes are difficult to prove secure except by using very
 large prrofs of knowledge [MOR01].
 As those proofs of knowledge/possession for the receivers' private keys.
 However, these schemes are difficult to prove secure except by using very
 large proofs of knowledge/possession do not need to be seen by verfiiers-
 they are effectively cetified by the sender's signature on teh transaction
 whihc includes the predicate- they do not burden validation.
 However, passing them arounf to senders is inconveneient, and easy to get
 wrong .Using a scheme that is secure in the 
\emph on
plain public-key model 
\emph default
categorically avoids these concerns.
 
\end_layout

\begin_layout Standard
Another alternative is to use an algorithm whose key generation requires
 a trusted setup, for example in the KOSK model.
 While many of these schemes have been proven secure [Bol03, LOS+06], they
 rely on mechanisms that are usually not implemented by certification aythoritie
s [BN06, RY07].
 
\end_layout

\begin_layout Subsection
Cross-Input Multi-Signatures 
\end_layout

\begin_layout Standard
The previous sections explained how the numbers of signautres per input
 can gnerally by reduced to one, but we would like to go further, and replace
 it with a signel signature per transaction.
 Doing so requires a fundamental change in validation semantics, as the
 validitiy of separate inputs is not loger independent.
 As a result , the outputs can no longer be modelled as predicates.
 Instead, we model them as functions that return a boolean plus a set of
 zero or more public keys.
 
\end_layout

\begin_layout Standard
Overall validity requires all returend booleans to be True and a multi-signature
 of the transaction with 
\begin_inset Formula $L$
\end_inset

 the union of all returned keys.
 
\end_layout

\begin_layout Standard
More concretly, this can be implemented by providing an alternative to the
 signature checking opcode 
\begin_inset ERT
status open

\begin_layout Plain Layout

OP_CHECKSIG
\end_layout

\end_inset

 and related opcodes in teh Script language.
 Instead of returning the reult of an actual ECDSA verification, they always
 return Ture, but additionally add the public key with which the verification
 would ave tekn place to a transaction-wide multiset of keys.
 Finally, after all inputs are verified, a multi-signature presnet in the
 transaction is verified against that multiset.
 In case the transaction spends inputs from multiple owners, they will need
 to collaborate to produce the multi-signture, or choose to only use the
 orginial opcodes.
 Adding these new opcodes is possible in backwa-compatible way.
 
\end_layout

\begin_layout Subsection
Protection against Rogue-Key Attacks 
\end_layout

\begin_layout Standard
When taking cross-inptu signatures input signatures, there is no published
 commitment to the set of signers,a s each transaction input can independetly
 spend an output that requires authorizartion from distinct participants.
 This functionality was not restrticited as it would then interfere with
 fungibility improvemtns like CoinJoin [Max13].
 Due to the lack of certitification, security against rogue-key attacks
 is of great importance.
 
\end_layout

\begin_layout Standard
If it is assumed that transactions used a single multi-signature that was
 vulnerable to rogue-attacks, like the simpler schemes previously descibed,
 an attacker could identify an arbitrarynumber of outputs he wants to steal,
 with the public keys 
\begin_inset Formula $X_{1},...,X_{n-t}$
\end_inset

 and then use the rogue-key 
\begin_inset Formula $X_{n-t+1},...,X_{n}$
\end_inset

 such that he can sign for the aggregated key 
\begin_inset Formula $\tilde{X}.$
\end_inset

He would then send a small amount of his own money to outputs with predicates
 corresponmding to the keys 
\begin_inset Formula $X_{n-t+1},...,X_{n}$
\end_inset

.
 Finally, he can create a transaction that spends all of the victim coins
 together with the ones he just dreated by forging a multi-signature for
 the whole transaction.
 
\end_layout

\begin_layout Standard
It can be seen that in the cse of mulit-signatures across inputs, theft
 can occur by merely being able to forge a signature over a set of keys
 that includes at least one key not controlled by the attacker, just what
 the 
\emph on
plain public-key model 
\emph default
considewrs a win for the attacker.
 This is in contrast to the single-inout multi-signature casem where theft
 is only possible by forging a signature for the exact (aggregated)keys
 contained in an exitisting output.
 As a result, it is no longer possible to rely on proofs of knowledge/possession
 that are private to the signers.
 
\end_layout

\begin_layout Standard
To anaylse the impact of multi-signatres, a simlation on Bitcoin's historical
 blockcahin was performed to determine the portential space saving.
 Figure 3 shows the cumlative blockchian size together with what the size
 would be if all transactions' signatures were replaced with just one per
 transtion, giving an idiciation of what could have been saved if 
\begin_inset Formula $\mathsf{MuSig}$
\end_inset

 had been used since the beginning.
 Note that this only encompasses the savings from using multi-signatures,
 and dones no tinduce the savings that are possible from key aggregation.
 
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "../Documents/The MuSig Schnorr Signature Scheme"
options "IEEEtran"

\end_inset


\end_layout

\end_body
\end_document
