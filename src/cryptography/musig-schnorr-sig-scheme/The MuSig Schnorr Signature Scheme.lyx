#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
The MuSig Schnorr Signature Scheme
\end_layout

\begin_layout Standard
This report investigates multi (MuSig), which is provably secure in the
 
\emph on
plain public-key model
\emph default
.
 However, the case of interactive signature aggregation where each signer
 signs their own message must still be proven by a complete security analysis.
 
\end_layout

\begin_layout Standard
Multi-signatures are a form of technology used to add additional security
 for cryptocurrency transactions.
 A multi-signature protocol which allows a group of signers to produce a
 short, joint signature on a common message.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Subsection
Schnorr signatures
\end_layout

\begin_layout Standard
Schnorr signatures produce a smaller on-chain size, support faster validation
 and have better privacy.
 They natively allow for combining multiple signatures into one through
 aggregation.
 They permit more complex spending policies.
 
\end_layout

\begin_layout Standard
Signature aggregation also has its challenges.
 This included the rogue-key attack, where a participant steals funds using
 a specifically constructed key.
 This is easily solved for simple multi-signatures, however, through an
 enrollment procedure, where the keys sign themselves, supporting it across
 multiple inputs of a transaction requires 
\emph on
plain public-key security
\emph default
, meaning there is no setup.
 
\end_layout

\begin_layout Standard
There is an additional attack, termed the Russel attacks, after Russel O'Connor,
 who was discovered that for multi-party schemes a party could claim ownership
 of someone else's key and so spend their other outputs.
 
\end_layout

\begin_layout Standard
That being said, Peter Wuille has been able to address some of these issues
 and has provided a solution which refines the Bellare-Neven (BN) scheme.
 He also discussed the performance improvements that were implemented for
 the scaler multiplication of the BN scheme and how they enable batch validation
 on the blockchain.
\begin_inset CommandInset citation
LatexCommand cite
key "Blocks2018"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
MuSig
\end_layout

\begin_layout Standard
A multi-signature scheme is a combination of a signing and verification
 algorithm, where multiple signers (each with their own private/public key)
 jointly sign a single message, resulting in a single signature.
 This can then be verified by anyone knowing the message and the public
 keys of the signers.
 
\end_layout

\begin_layout Standard
MuSig is a simple multi-signature scheme that is novel in combining:
\end_layout

\begin_layout Enumerate
Support for key aggregation; 
\end_layout

\begin_layout Enumerate
Security in the 
\emph on
plain public-key model
\emph default
.
 
\end_layout

\begin_layout Standard
There are two versions of MuSig, that are provably secure, which differ
 based on the number of communication rounds:
\end_layout

\begin_layout Itemize
Three-round MuSig only relies on the Discrete Logarithm (DL) assumption,
 on which ECDSA (Elliptic Curve Digital Signature Algorithm) also relies
 
\end_layout

\begin_layout Itemize
Two-round MuSig instead relies on the slightly stronger One-More Discrete
 Logarithm (OMDL) assumption
\end_layout

\begin_layout Subsection
Key aggregation
\end_layout

\begin_layout Standard
The term 
\emph on
key aggregation
\emph default
 refers to multi-signatures that look like a single-key signature, but with
 respect to an aggregated public key that is a function of only the participants
' public keys.
 Thus, verifiers do not require the knowledge of the original participants'
 public keys- they can just be given the aggregated key.
 In some use cases, this leads to better privacy and performance.
 Thus, MuSig is effectively a key aggregation scheme for Schnorr signatures.
 
\end_layout

\begin_layout Standard
There are other multi-signature schemes that already exist that provide
 key aggregation for Schnorr signatures, however they come with some limitations
, such as needing to verify that participants actually have the private
 key corresponding to the pubic keys that they claim to have.
 
\emph on
Security in the plain public-key model 
\emph default
means that no limitations exist.
 All that is needed from the participants is their public keys.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wuille2018"
literal "false"

\end_inset

 
\end_layout

\begin_layout Section
Applications of multi-signatures 
\end_layout

\begin_layout Standard
Recently most obvious use case for multi-signatures, is with regards to
 Bitcoin, where it can function as a more efficient replacement of 
\emph on
n
\emph default
-of-
\emph on
n
\emph default
 multisig scripts and other policies that permit a number of possible combinatio
ns of keys.
 For these, a native multi-signature scheme means that what is left is one
 signature per transaction input.
 
\end_layout

\begin_layout Standard
A key aggregation scheme also lets one reduce the number of public keys
 per input to one, as a user can send coins to the aggregate of all involved
 key, rather than including them all in the script.
 This leads to smaller on-chain footprint, faster validation, and better
 privacy.
 
\end_layout

\begin_layout Standard
Instead of creating restrictions with one signature per input, one signature
 can be used for the entire transaction.
 Key aggregation cannot be used across multiple inputs, as the public keys
 are committed to by the outputs, and those can be spent independently.
 MuSig can be used here (with key aggregation done by the verifier).
 
\end_layout

\begin_layout Standard
On a technical standing, in order to combine all the transaction inputs'
 signatures, a multi-signature scheme is not necessary, instead an aggregate
 signature scheme can be used.
 The distinction is simply that in an aggregate signature, each signer has
 their own message, instead of one message shared by all.
 
\end_layout

\begin_layout Standard
Aggregate signatures can be categorized as being:
\end_layout

\begin_layout Itemize
Interactive: Interactive aggregate signatures (IAS) require the signers
 to cooperate, while non-interactive schemes all the aggregation to be done
 by anyone
\end_layout

\begin_layout Itemize
Non-interactive: These allow the aggregation to be done by anyone
\end_layout

\begin_layout Standard
No non-interactive aggregation schemes are known that only rely on the DL
 assumption, but interactive ones are trivial to construct: where a multi-signat
ure scheme has every participant sign the concatenation of all messages.
 The paper by Blockstream, focusing on key aggregation for Schnorr Signatures
 shows that this is not always a desirable construction, and gives an IAS
 variant of BN with better properties instead.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wuille2018"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Simple Schnorr Multi-Signatures 
\end_layout

\begin_layout Standard
The paper describes a new Schnorr-based multi-signature scheme called MuSig,
 which is provably secure in the 
\emph on
plain public-model.
 
\emph default
This means that signers are only required to have a public key, but they
 do not have to prove knowledge of the private key corresponding to their
 public key to some certification authority or to other signers prior to
 engaging the protocol.
 
\end_layout

\begin_layout Standard
This new scheme provides improvements to Bellare and Neven (ACM-CCS 2006)
 and its variants by Bagherzandi 
\emph on
et al.
 
\emph default
(ACM-CCS 2008) and Ma 
\emph on
et al.
 
\emph default
(Des.
 Codes Cryptogr., 2010)
\emph on
 
\begin_inset Marginal
status collapsed

\begin_layout Plain Layout
Write Sections on Bagerzandi and Ma
\end_layout

\end_inset


\emph default
in two respects: 
\end_layout

\begin_layout Enumerate
It is simple and efficient, as it has the same key and signature size as
 standard Schnorr signatures; 
\end_layout

\begin_layout Enumerate
It allows 
\emph on
key aggregation
\emph default
, where the joint signature can be verified just as a standard Schnorr signature
 with respect to a single 
\begin_inset Quotes eld
\end_inset

aggregated
\begin_inset Quotes erd
\end_inset

 public key which can be computed from the individual public keys of the
 signers.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
Multi-signatures 
\end_layout

\begin_layout Standard
Introduced by Itakura and Nakamura 
\begin_inset CommandInset citation
LatexCommand cite
key "Itakura1983"
literal "false"

\end_inset

, multi-signature protocols allow a group of signers (that individually
 possess their own private/public key pair) to produce a single signature
 
\begin_inset Formula $\sigma$
\end_inset

on a message 
\begin_inset Formula $m$
\end_inset

.
 Verification of the given signature 
\begin_inset Formula $\sigma$
\end_inset

can be publicly performed given the message and the set of public keys of
 all signers.
 
\end_layout

\begin_layout Standard
A simple way to change a standard signature scheme into a multi-signature
 scheme is to have each signer produce a stand-alone signature for 
\begin_inset Formula $m$
\end_inset

 with its private key and to then concatenate all individual signatures.
 
\end_layout

\begin_layout Standard
The transformation of a standard signature scheme to a multi-signature scheme
 needs to useful and practical, thus the newly calculated multi-signature
 scheme must produce signatures where the size is independent of the number
 of signers and similar to that of the original signature scheme.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Rogue attacks 
\end_layout

\begin_layout Standard
Rogue attacks are a significant concern when implementing multi-signature
 schemes.
 Here a subset of corrupted singers, manipulate the public keys computed
 as functions of the public keys of honest users, allowing them to easily
 produce forgeries for the set of public keys (despite them not knowing
 the associated secret keys.
 
\end_layout

\begin_layout Standard
Proposals from 
\begin_inset CommandInset citation
LatexCommand cite
key "Li1994"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Harn1994"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Horster1995"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Ohta1991"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Langford1996"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Michels1996"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Ohta1999"
literal "false"

\end_inset

 were thus undone before a formal model was put forward along with a provably
 secure scheme from Micali, Ohta, and Reyzin.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Micali2001"
literal "false"

\end_inset

Unfortunately, despite being provably secure this scheme is costly and an
 impractical interactive key generation protocol.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
A means of generically preventing rogue-key attacks is to make it mandatory
 for users to prove knowledge (or possession 
\begin_inset CommandInset citation
LatexCommand cite
key "Ristenpart2007"
literal "false"

\end_inset

) of the secret key during public key registration with a certification
 authority.
 Certification authority is a setting known as the knowledge of secret key
 (KOSK) assumption.
 The pairing-based multi-signature schemes by Boldyreva 
\begin_inset CommandInset citation
LatexCommand cite
key "Boldyreva2003"
literal "false"

\end_inset

 and Lu 
\emph on
et al
\emph default
.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Lu2006"
literal "false"

\end_inset

 rely on the KOSK assumption in order to maintain security.
 However, this as can be seen from 
\begin_inset CommandInset citation
LatexCommand cite
key "Bellare2006"
literal "false"

\end_inset

and 
\begin_inset CommandInset citation
LatexCommand cite
key "Ristenpart2007"
literal "false"

\end_inset

 this assumption is problematic.
 
\end_layout

\begin_layout Standard
As it stands, the Bellare and Neven 
\begin_inset CommandInset citation
LatexCommand cite
key "Bellare2006"
literal "false"

\end_inset

 provides the most practical multi-signature scheme, based on the Schnorr
 signature scheme, which is provably secure that does not contain any assumption
 on the key setup.
 Since the only requirement of this scheme is that each potential signer
 has a public key, this setting is referred to as the 
\emph on
plain-key model.
 
\end_layout

\begin_layout Subsubsection
Schnorr signature scheme 
\end_layout

\begin_layout Standard
The Schnorr signature scheme uses:
\begin_inset CommandInset citation
LatexCommand cite
key "Schnorr1991"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
A cyclic group 
\begin_inset Formula $G$
\end_inset

 of prime order 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Itemize
A generator 
\begin_inset Formula $g$
\end_inset

of 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Itemize
A hash function 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Itemize
A private/public key pair is a pair 
\begin_inset Formula $(x,X)$
\end_inset


\begin_inset Formula $\epsilon\{0,...,p-1\}$
\end_inset


\begin_inset Formula $\mathsf{x}$
\end_inset


\begin_inset Formula $G$
\end_inset

 where 
\begin_inset Formula $X=g^{x}$
\end_inset


\end_layout

\begin_layout Itemize
To sign a message 
\begin_inset Formula $m$
\end_inset

, the signer draws a random integer 
\begin_inset Formula $r$
\end_inset

in 
\begin_inset Formula $Z_{p},$
\end_inset

 computes 
\begin_inset Formula $R=g^{r}$
\end_inset

, 
\begin_inset Formula $c=H(X,R,m)$
\end_inset

, and 
\begin_inset Formula $s=r+cx$
\end_inset


\end_layout

\begin_layout Itemize
The signature is the pair 
\begin_inset Formula $(R,s)$
\end_inset

 , and its validity can be checked by verifying whether 
\begin_inset Formula $g^{s}=RX^{c}$
\end_inset


\end_layout

\begin_layout Standard
The above described is referred to as the so-called 
\begin_inset Quotes eld
\end_inset

key-prefixed
\begin_inset Quotes erd
\end_inset

 variant of the scheme, which sees the public key hashed together with 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Bernstein2012"
literal "false"

\end_inset

.
 This variant was thought to have a better multi-user security bound than
 the classic variant 
\begin_inset CommandInset citation
LatexCommand cite
key "Bernstein2015"
literal "false"

\end_inset

, however in 
\begin_inset CommandInset citation
LatexCommand cite
key "Kiltz2016"
literal "false"

\end_inset

 the key-prefixing was seen as unnecessary to enable good multi-user security
 for Schnorr signatures.
 
\end_layout

\begin_layout Standard
For the development of the new Schnorr-based multi-signature scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "Maxwell2018"
literal "false"

\end_inset

, key-prefixing seemed a requirement for the security proof to go through,
 despite not knowing the form of an attack.
 The rationale also follows the process in reality, as messages signed in
 Bitcoin always indirectly commits to the public key.
 
\end_layout

\begin_layout Subsubsection
Design of a Schnorr multi-signature scheme
\end_layout

\begin_layout Standard
The naive way to design a Schnorr multi-signature scheme would be as follows:
\end_layout

\begin_layout Itemize
A group of 
\begin_inset Formula $n$
\end_inset

signers want to cosign a message 
\begin_inset Formula $m$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Let 
\begin_inset Formula $L=\{X_{1}=g^{x_{1}},...,X_{n}=g^{x_{n}}\}$
\end_inset

 be the multi-set of all public keys 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
No constraints are imposed on the key setup, the adversary thus can choose
 corrupted public keys at random, hence the same public key can appear more
 than once in 
\begin_inset Formula $L$
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Each cosigner randomly generates and communicates to others a share 
\begin_inset Formula $R_{i=}$
\end_inset


\begin_inset Formula $g^{r_{i}}$
\end_inset


\end_layout

\begin_layout Itemize
Each of the cosigners them computes 
\begin_inset Formula $R=$
\end_inset


\begin_inset Formula $\Pi_{_{i=1}}^{n}$
\end_inset


\begin_inset Formula $R_{i}$
\end_inset

, 
\begin_inset Formula $c=H(\tilde{X},R,m)$
\end_inset

 
\end_layout

\begin_layout Itemize
Where 
\begin_inset Formula $\tilde{X}=\Pi_{i=1}^{n}X_{i}$
\end_inset

 is the product of individual public keys, and a partial signature 
\begin_inset Formula $s_{i}=r_{i}+cx_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Partial signatures are then combined into a single signature 
\begin_inset Formula $(R,s)$
\end_inset

 where 
\begin_inset Formula $s=\Sigma_{i=1}^{n}si$
\end_inset

 mod 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Itemize
The validity of a signature 
\begin_inset Formula $(R,s)$
\end_inset

 on message 
\begin_inset Formula $m$
\end_inset

 for public keys 
\begin_inset Formula $\{X_{1},...X_{n}\},$
\end_inset

is equivalent to 
\begin_inset Formula $g^{s}=R\tilde{X}^{c}$
\end_inset

 where 
\begin_inset Formula $\tilde{X}=\Pi_{i=1}^{n}X_{i}$
\end_inset

 and 
\begin_inset Formula $c=H(\tilde{X},R,m)$
\end_inset


\end_layout

\begin_layout Itemize
Note that this is exactly the verification equation for a traditional key-prefix
ed Schnorr signature with respect to public key 
\begin_inset Formula $\tilde{X}$
\end_inset

, a property termed 
\emph on
key aggregation 
\end_layout

\end_deeper
\begin_layout Standard
However, as mentioned above, 
\begin_inset CommandInset citation
LatexCommand cite
key "Horster1995"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Langford1996"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "Michels1996"
literal "false"

\end_inset

 and
\begin_inset CommandInset citation
LatexCommand cite
key "Micali2001"
literal "false"

\end_inset

 these protocols are vulnerable to a rogue-key attack where a corrupted
 signer sets its public key to 
\begin_inset Formula $X_{1}=g^{x_{1}}(\Pi_{i=2}^{n}X_{i})^{-1}$
\end_inset

, allowing the signer to produce signatures for public keys 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\{X_{1},...X_{n}\}$
\end_inset

 by themself.
\end_layout

\begin_layout Subsubsection
Micali-Ohta-Reyzin Multi-signature scheme 
\end_layout

\begin_layout Standard
The Micali-Ohta-Reyzin multi-signature scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "Micali2001"
literal "false"

\end_inset

solves the rogue-key attack using a sophisticated interactive key generation
 protocol.
 
\end_layout

\begin_layout Subsubsection
Bellare and Neven signature scheme
\end_layout

\begin_layout Standard
Bellare-Neven (BN) 
\begin_inset CommandInset citation
LatexCommand cite
key "Bellare2006"
literal "false"

\end_inset

proceeded differently in order to avoid any key setup.
 It is a more widely known plain public-key multi-signature scheme, that
 does not support key aggregation.
 It is possible to use BN multi-signatures where the individual keys are
 MuSig aggregates.
 BN multi-signature scheme is secure without such assumptions.
 Below are details:
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $L=H(X_{1,}X_{2...})$
\end_inset


\end_layout

\begin_layout Itemize
Each signer chooses a random nonce 
\begin_inset Formula $r_{i}$
\end_inset

 and shares 
\begin_inset Formula $R$
\end_inset


\begin_inset Formula $_{i}=r_{i}G$
\end_inset

 with the other signers
\end_layout

\begin_layout Itemize
Call R the sum of the 
\begin_inset Formula $R_{i}$
\end_inset

 points 
\end_layout

\begin_layout Itemize
Each signer computes 
\begin_inset Formula $s_{i}=r_{i}+H(L,X_{i,}R,m)x_{i}$
\end_inset


\end_layout

\begin_layout Itemize
The final signature is 
\begin_inset Formula $(R,s)$
\end_inset

 where 
\begin_inset Formula $s$
\end_inset

is the sum of the 
\begin_inset Formula $s_{i}$
\end_inset

 values 
\end_layout

\begin_layout Itemize
Verification requires 
\begin_inset Formula $sG=R+H(L,X_{1,}R,m)X_{2}+...$
\end_inset


\end_layout

\begin_layout Standard
Technically, BN has a pre-commit round, where the signers initially reveal
 
\begin_inset Formula $H(R_{i})$
\end_inset

to each other, prior to revealing the 
\begin_inset Formula $R_{i}$
\end_inset

 points themselves.
 This step is a requirement in order to prove security under the DL assumption,
 but it can be dismisses if instead the OMDL assumption is accepted.
 
\end_layout

\begin_layout Standard
Furthermore, when an IAS is desired (where each signer has their own message),
 
\begin_inset Formula $L=H((X_{1},m_{1)},(X_{2},m_{2}),...)$
\end_inset

 and 
\begin_inset Formula $s_{i}=r_{i}+H(L,R,i)x_{i}$
\end_inset

 is used for signing (and analogous for verification).
 
\end_layout

\begin_layout Standard
The resulting signature does not satisfy the normal Schnorr equation anymore,
 nor any other equation that can be written as a function of a combination
 of the public keys; the key aggregation property is lost in order to gain
 security in the plain public-key model.
 
\end_layout

\begin_layout Standard
This is where MuSig comes in.
 It recovers the 
\emph on
key aggregation property without losing security:
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $L=H(X_{1},X_{2}...)$
\end_inset


\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $X$
\end_inset

 the sum of all 
\begin_inset Formula $H(L,X_{i})X_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Each signer chooses a random nonce 
\begin_inset Formula $r_{i},$
\end_inset

 and shares 
\begin_inset Formula $R$
\end_inset


\begin_inset Formula $_{i}=r_{i}G$
\end_inset

 with the other signers 
\end_layout

\begin_layout Itemize
Call 
\begin_inset Formula $R$
\end_inset

 the sum of the 
\begin_inset Formula $R$
\end_inset


\begin_inset Formula $_{i}$
\end_inset

 points 
\end_layout

\begin_layout Itemize
Each signer computes 
\begin_inset Formula $s_{i}=r_{i}+H(X,R,m)H(L,X_{i})x_{i}$
\end_inset


\end_layout

\begin_layout Itemize
The final signature is 
\begin_inset Formula $(R,s)$
\end_inset

 where 
\begin_inset Formula $s$
\end_inset

is the sum of the 
\begin_inset Formula $s_{i}$
\end_inset

 values 
\end_layout

\begin_layout Itemize
Verification again satisfies 
\begin_inset Formula $sG=R+H(X,R,m)X$
\end_inset


\end_layout

\begin_layout Standard
So what was needed was to define 
\begin_inset Formula $X$
\end_inset

 not as a simple sum of the individual public keys 
\begin_inset Formula $X_{i},$
\end_inset

but as a sum of multiples of those keys, where the multiplication factor
 depends on a hash of all participating keys.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wuille2018"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Their main idea is to have each cosigner use a distinct 
\begin_inset Quotes eld
\end_inset

challenge
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $c_{i}$
\end_inset

when computing their partial signature 
\begin_inset Formula $s_{i}=r_{i}+c_{i}x_{i},$
\end_inset

defined as 
\begin_inset Formula $c_{i}=H(<L>X_{i},R,m),$
\end_inset

where as before 
\end_layout

\begin_layout Standard
Bellare and Neven showed that this yields a multi-signature scheme provably
 secure in the 
\emph on
plain public-key 
\emph default
model under the Discrete Logarithm assumptions, modeling 
\begin_inset Formula $H$
\end_inset

and 
\begin_inset Formula $H'$
\end_inset

as random oracles.
 However, this scheme does not allow key aggregation anymore since the entire
 list of public keys is required for verification.
 
\end_layout

\begin_layout Subsubsection
The new scheme
\end_layout

\begin_layout Standard
The new proposed Schnorr-based multi-signature scheme can be seen as a variant
 of the BN scheme, allowing key aggregation in the 
\emph on
plain public-key model.
 
\emph default
This scheme consists of three rounds, the first two being exactly the same
 as in BN.
 Challenges 
\begin_inset Formula $c_{i}$
\end_inset

 are changed from 
\begin_inset Formula $c_{i}=H(<L>X_{i},R,m)$
\end_inset

 to 
\begin_inset Formula $c_{i}=H_{agg}(<L>X_{i}).H_{sig}(\tilde{X,}R,m)$
\end_inset

 , where 
\begin_inset Formula $\tilde{X}$
\end_inset

is the so-called aggregated public key corresponding to the multi-set of
 public keys 
\begin_inset Formula $L=\{X_{1},...X_{n}\},$
\end_inset

 defined as 
\begin_inset Formula $\tilde{X}=\stackrel[i=1]{n}{\Pi}X_{i}^{a_{i}c}=R\tilde{X}^{c}$
\end_inset

 where 
\begin_inset Formula $c=H_{sig}(\tilde{X},R,m).$
\end_inset


\end_layout

\begin_layout Standard
Basically , the key aggregation property has been recovered and can now
 be enjoyed by the naive scheme, which respect to a more complex aggregation
 key 
\begin_inset Formula $\tilde{X}=\stackrel[i=1]{n}{\Pi}X_{i}^{a_{i}c}$
\end_inset

.
 
\begin_inset Formula $c=H_{sig}(<L>,R,m)$
\end_inset

 yields a secure scheme, however does not allow key aggregation since verificati
on is impossible without knowing all the individual singer keys.
 
\end_layout

\begin_layout Subsubsection
The benefits of key aggregation 
\end_layout

\begin_layout Itemize
If a group of 
\begin_inset Formula $n$
\end_inset

signers want to authorize which all of them agree, but do not necessarily
 wish to reveal their individual public keys 
\end_layout

\begin_layout Itemize
They can privately compute the aggregated key 
\begin_inset Formula $\tilde{X}$
\end_inset

 corresponding to their multi-set of public keys and publish it as an ordinary
 (non-aggregated) key.
 
\end_layout

\begin_layout Itemize
Signers are ensured that all of them will need to cooperate to produce a
 signature which is valid under 
\begin_inset Formula $\tilde{X}$
\end_inset

, whereas verifiers will not even learn that 
\begin_inset Formula $\tilde{X}$
\end_inset

is in fact an aggregated key.
 
\end_layout

\begin_layout Itemize
Moreover, 
\begin_inset Formula $\tilde{X}$
\end_inset

can be computed by a third party just from the list of public keys, without
 interacting with the signers.
\end_layout

\begin_layout Itemize
This property will prove instrumental for obtaining a more compact and privacy-p
reserving variant of so-called 
\emph on
n-
\emph default
of-
\emph on
n 
\emph default
multi-signature transactions in Bitcoin.
 
\end_layout

\begin_layout Standard
Two variants of the BN multi-signature scheme have been previously proposed.
 
\end_layout

\begin_layout Subsubsection
The Bagherzandi 
\emph on
et al.
 
\emph default
scheme
\end_layout

\begin_layout Standard
Bagherzandi 
\emph on
et al.
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Bagherzandi2008"
literal "false"

\end_inset

 reduced the number of rounds from three to two using an homomorphic commitment
 scheme.
 Unfortunately, this increases the signature size and the computational
 cost of signing and verification.
 
\end_layout

\begin_layout Subsubsection
The Ma 
\emph on
et al.

\emph default
 scheme 
\end_layout

\begin_layout Standard
Ma 
\emph on
et al.
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Ma2010"
literal "false"

\end_inset

proposed a variation based on Okamoto's signature scheme
\begin_inset CommandInset citation
LatexCommand cite
key "Okamoto1992"
literal "false"

\end_inset

, which involved the 
\begin_inset Quotes eld
\end_inset

double hashing
\begin_inset Quotes erd
\end_inset

 technique, which sees the reduction of the signature size compared to 
\begin_inset CommandInset citation
LatexCommand cite
key "Bagherzandi2008"
literal "false"

\end_inset

while using only two rounds.
 
\end_layout

\begin_layout Standard
However, neither of these two variants allow for key aggregation.
 
\end_layout

\begin_layout Standard
Multi-signature schemes supporting key aggregation are easier to come by
 in the KOSK model.
 In particular, Syta 
\emph on
et al.

\emph default
 proposed
\emph on
 
\emph default
the CoSi scheme which can be seen as the naive Schnorr multi-signature scheme
 described earlier where the co-signers are organized in a tree structure
 for fast signature generation.
 
\end_layout

\begin_layout Section
Interactive Aggregate Signatures
\end_layout

\begin_layout Standard
In some situations, it may be useful to allow each participant to sign a
 different message rather than a single common one.
 An interactive aggregate signature (IAS) is one where each signer has its
 own message 
\emph on

\begin_inset Formula $m_{i}$
\end_inset

 
\emph default
to sign, and the joint signature proves that the 
\begin_inset Formula $i$
\end_inset

-th signer has signed 
\begin_inset Formula $m_{i}$
\end_inset

 .
 These schemes are more general than multi-signature schemes, however they
 are less flexible than non-interactive aggregate signatures 
\begin_inset CommandInset citation
LatexCommand cite
key "Boneh2003,Bellare2007"
literal "false"

\end_inset

 and sequential aggregate signatures [LMRSO4].
 
\end_layout

\begin_layout Standard
According to Bellare and Neven [BN06], they suggested a generic way to turn
 any multi-signature scheme into an IAS scheme by the signer running the
 multi-signature protocol using as message the tuple of all public keys/message
 pairs involved in the IAS protocol.
 
\end_layout

\begin_layout Standard
For BN's scheme and the scheme of the Blockstream signature scheme, this
 does not increase the number of communication rounds as messages can be
 sent together with shares 
\begin_inset Formula $R_{i}$
\end_inset

.
 
\end_layout

\begin_layout Standard
However, the problem arise with the generic construction in the 
\emph on
plain public-key model.
 
\emph default
Below is a closer look at transformation and show that is subtly fails to
 provide the strongest security guarantees in the 
\emph on
plain public key model.
 
\end_layout

\begin_layout Subsection
Syntax and security model 
\end_layout

\begin_layout Standard
The syntax is adapted as follows.
 An IAS scheme 
\emph on
II
\emph default
 is a triple of algorithms 
\begin_inset Formula $\mathsf{(\mathsf{KeyGen,Sign,}Ver).}$
\end_inset

 The randomization key generation algorithm takes no input and returns a
 private/public key pair 
\begin_inset Formula $\mathsf{(sk,pk)}\leftarrow_{\$}\mathsf{KeyGen()}.$
\end_inset

 The signature algorithm 
\begin_inset Formula $\mathsf{Sign}$
\end_inset

 is run by each participant on input its key pair 
\begin_inset Formula $\mathsf{(sk,pk)}$
\end_inset

, a message 
\begin_inset Formula $m$
\end_inset

, and a set of public key/message pairs for other cosigners 
\begin_inset Formula $S'=\left\{ (pk_{1}^{'},m_{1}^{'}),...(pk_{n-1}^{'},m_{n-1}^{'})\right\} $
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(\mathsf{pk,}m)$
\end_inset


\begin_inset Formula $\notin S'$
\end_inset

; it returns a signature 
\begin_inset Formula $\sigma$
\end_inset

for the set of public key/message pairs 
\begin_inset Formula $S=S'\cup\{(\mathsf{pk,}m)\}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $S$
\end_inset

 is a set, i.e., no public key/message pair repeats, even though the same
 public key might appear mulitple times.
 This is without loss of generality since any repeated public key/message
 pair in 
\begin_inset Formula $S$
\end_inset

 can be deleted by the signature/verification algorithm.
\end_layout

\end_inset

 The deterministic verification algorithm 
\begin_inset Formula $\mathsf{Ver}$
\end_inset

 takes as input a set of public key/message pairs 
\begin_inset Formula $S=\{(\mathsf{pk_{1},}m_{1}),...,(\mathsf{pk_{n},}m_{n})\}$
\end_inset

 and a signature 
\begin_inset Formula $\sigma$
\end_inset

, and returns 1 if the signature is valid for 
\begin_inset Formula $S$
\end_inset

 and 0 otherwise.
 
\end_layout

\begin_layout Standard
As another means, one can specify the signature algorithm to take as input
 a key pair 
\end_layout

\begin_layout Subsection
Revisions 
\end_layout

\begin_layout Standard
A previous version of this paper, dated January 15, 2918, proposed a 2-round
 variant of 
\begin_inset Formula $\mathsf{MuSig}$
\end_inset

, where the initial commitment round is omitted claiming a security proof
 unsure the One More Discrete Logarithm (OMDL) assumptions [BP02][BNPS03].
 However, a flaw in the security proof was discovered by Drijvers 
\emph on
et al.
 
\emph default
[DEFN18], how also showed through a meta-reduction that this scheme cannot
 be proved secure using an algebraic black box reduction under the DL or
 OMDL assumption (assuming the OMDL problem is hard).
 
\end_layout

\begin_layout Standard
In more details, observe that in the 2-round variant of 
\begin_inset Formula $\mathsf{MuSig}$
\end_inset

, an adversary (controlling public keys 
\begin_inset Formula $X_{2},...,X_{n})$
\end_inset

 can impose the value of 
\begin_inset Formula $R=\Pi_{i=1}^{n}R_{i}$
\end_inset

 used in signature protocols since he can choose 
\begin_inset Formula $R_{2},...,R_{n}$
\end_inset

after having received 
\begin_inset Formula $R_{1}$
\end_inset

from the honest signer (controlling public key 
\begin_inset Formula $X_{1}=g^{x_{1}}$
\end_inset

).
 This forbids to use the textbook way of simulating the honest signer in
 the Random Oracle model without knowing 
\begin_inset Formula $x_{1}$
\end_inset

 by randomly drawing 
\begin_inset Formula $s_{1}$
\end_inset

 and 
\begin_inset Formula $c$
\end_inset

, computing 
\end_layout

\begin_layout Standard
There is no attach currently known against the 2-round variant of MuSig
 and that it might be secure although thais is not provable under standard
 assumptions from existing techniques.
 
\end_layout

\begin_layout Section
The Discrete Logarithm Problem 
\end_layout

\begin_layout Standard
Definition 1 (DL problem)
\end_layout

\begin_layout Itemize
Let 
\begin_inset Formula $\mathbb{G}$
\end_inset

 
\begin_inset Formula $,p,g$
\end_inset

 be group parameters- it is fixed, but the bit length 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

can be regarded as a security parameter if necessary.
 
\end_layout

\begin_layout Itemize
An algorithm 
\begin_inset Formula $\mathcal{A}$
\end_inset

 is said to 
\begin_inset Formula $(t,\varepsilon solve$
\end_inset

the DL problem with with respect to 
\begin_inset Formula $\mathbb{G},p,g$
\end_inset

 if on input a random group element 
\begin_inset Formula $X$
\end_inset

, it runs in time at most 
\begin_inset Formula $t$
\end_inset

 and returns 
\begin_inset Formula $x\in\{0,...,p-1\}$
\end_inset

 such that 
\end_layout

\begin_layout Section
Elliptic Curve Digital Signature Algorithm 
\end_layout

\begin_layout Standard
Currently in Bitcoin ECDSA is implemented.
 To sign a message 
\begin_inset Formula $m$
\end_inset

 we hash it and treat this hash as a number: 
\begin_inset Formula $z=hash(m)$
\end_inset

.
 We also need a random or random-looking number 
\begin_inset Formula $k$
\end_inset

.
 We prefer not to trust random number generators (too many failures and
 vulnerabilities are related to bad random number generators) so we usually
 use 
\bar under
RFC6979
\bar default
 to calculate deterministic 
\begin_inset Formula $k$
\end_inset

 based on our secret and the message we are signing.
 
\end_layout

\begin_layout Standard
Using a private key 
\begin_inset Formula $pk$
\end_inset

 we can generate a signature for message 
\begin_inset Formula $m$
\end_inset

 consisting of two numbers: 
\begin_inset Formula $r$
\end_inset

(
\begin_inset Formula $x$
\end_inset

coordinate of the random point 
\begin_inset Formula $R=kG$
\end_inset

 and 
\begin_inset Formula $s=(z+rpk)/k$
\end_inset

.
 Then, using our public key 
\begin_inset Formula $P=pkG$
\end_inset

 anyone can verify our signature by checking that point 
\begin_inset Formula $(\frac{z}{s})G+(\frac{r}{s})P$
\end_inset

 has 
\begin_inset Formula $x$
\end_inset

coordinate equal to 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\begin_layout Standard
Insert Image 
\end_layout

\begin_layout Standard
This algorithm is very common, however it can be improved.
 Firstly, signature verification includes inversion 
\begin_inset Formula $(1/s)$
\end_inset

 and two points multiplications an these operations are very computationally
 heavy.
 In Bitcoin every node has to verify all the transactions.
 This means that when you broadcast a transaction, thousands of computers
 will have to verify your signature.
 Making verification process simpler will be very beneficial even if signing
 is more difficult.
 
\end_layout

\begin_layout Standard
Secondly, every node has to verify every signature individually.
 In the case of m-of-n multisig transaction node may even have to verify
 the same signature several times.
 For example, transaction of 7-of-11 multisig input will contain 7 signatures
 and require from 7 to 11 signature verifications on every node in the network.
 Also such transaction will take a huge amount of space in the block and
 you will have to pay large fees for that.
 
\end_layout

\begin_layout Section
Schnorr signatures 
\end_layout

\begin_layout Standard
Schnorr signatures are generated slightly differently.
 Instead of two scalars 
\begin_inset Formula $(r,s)$
\end_inset

we use a point 
\begin_inset Formula $R$
\end_inset

 and a scalar .
 Like ECDSA, 
\begin_inset Formula $R$
\end_inset

 is considered a random point on the elliptic curve 
\begin_inset Formula $(R=kG)$
\end_inset

.
 Second part of the signature is calculated slightly differently: 
\begin_inset Formula $s=k+hash(P,R,m)pk$
\end_inset

.
 Here 
\begin_inset Formula $pk$
\end_inset

 is your private key, 
\begin_inset Formula $P=pkG$
\end_inset

 is your public key, 
\begin_inset Formula $m$
\end_inset

 is the message.
 Then once can verify this signature by checking that 
\begin_inset Formula $sG=R+hash(P,R,m)P$
\end_inset


\end_layout

\begin_layout Standard
Insert image: Visualization of the Schnorr signature verification 
\end_layout

\begin_layout Standard
This equation is linear, so equations can be added and subtracted with each
 other and still stay valid.
 This leads to a nice feature of Schnorr signatures.
\end_layout

\begin_layout Subsection
Batch validation 
\end_layout

\begin_layout Standard
To verify a block in Bitcoin blockchain we need to make sure that all signatures
 in the block are valid.
 If one of them is not valid we don't care which one- we just reject eh
 whole block and that's it.
 
\end_layout

\begin_layout Standard
With ECDSA every signature has to be verified separately.
 Meaning that if we have 1000 signatures in the block we will need to compute
 1000 inversions and 2000 point multiplication.
 In total approximately 3000 heavy operations.
\end_layout

\begin_layout Standard
With Schnorr signatures we can add up all the signature verification equations
 and save some computational power.
 In total for a block with 1000 transactions we need to verify that:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $(s1+s2+...+s1000)G=(R1+...+R1000)+(hash(P1,R1,m1)P1+hash(P2,R2,m2)P2+...+hash(P1000,R1000,m1000)P1000$
\end_inset


\end_layout

\begin_layout Standard
Here we have a bunch of point additions (almost free in sense of computational
 power) and 1001 point multiplication.
 This is already a factor of 3 improvement- we meed to compute roughly one
 heavy operation per signature.
 
\end_layout

\begin_layout Standard
Insert image: Batch validation of two signatures.
 As verification equation is linear the sum of several equations is valid
 as soon as all signatures are valid.
 We save some computational power as scalar and point additions are much
 easier than point multiplication.
 
\end_layout

\begin_layout Subsection
Key aggregation 
\end_layout

\begin_layout Standard
There is a need to keep one's bitcoin safe, so we might want to use at least
 two different private keys to control bitcoins.
 Once we will use on a laptop or a phone and another one- on a hardware
 wallet/cold wallet.
 So when one of them is compromised we still have control over our bitcoins.
 
\end_layout

\begin_layout Standard
Currently it is implemented via 2-of-2 multi-signature script.
 This requires two separate signatures to be included in the transaction.
\end_layout

\begin_layout Standard
With Schnorr signatures we can use a pair of private keys 
\begin_inset Formula $(pk1,pk2)$
\end_inset

 and generate a shared signature corresponding to a shared public key 
\begin_inset Formula $P=P1+P2=pk1G+pk2G$
\end_inset

.
 To generate this signature we need to choose a random number on every device
 
\begin_inset Formula $(k1,k2)$
\end_inset

, generate a random point 
\begin_inset Formula $Ri=kiG$
\end_inset

, add them up to calculate a common 
\begin_inset Formula $hash(P,R1+R2,m)$
\end_inset

 and then get 
\begin_inset Formula $s1$
\end_inset

 and 
\begin_inset Formula $s2$
\end_inset

 from every device 
\begin_inset Formula $(si=ki+hash(P,R,m)pki)$
\end_inset

.
 Then we can add up these signatures and use a pair 
\begin_inset Formula $(R,s)=(R1+R2,s1+s2)$
\end_inset

as our signature for shared public key 
\begin_inset Formula $P.$
\end_inset

 Everyone else won't be able to say if it is an aggregated signature or
 
\end_layout

\begin_layout Subsection
Merkle multi-signatures
\end_layout

\begin_layout Standard
MuSig and key aggregation require all signers to sign a transaction.
 What happens if you want to make a 2-of-3 multisig? Can one use signature
 aggregation or will we have to use our usual OP_CHECKMULTISIG and separate
 signatures?
\end_layout

\begin_layout Standard
it is possible, but with a small change in the protocol.
 A new op-code similar to OP_CHECKMULTISIG can be developed that checks
 if aggregated signature corresponds to a particular item in the Merkle
 tree of public keys.
 
\end_layout

\begin_layout Standard
For example, if we use a 2-of-3 multisig with public keys 
\begin_inset Formula $P1$
\end_inset

, 
\begin_inset Formula $P2$
\end_inset

 and 
\begin_inset Formula $P3$
\end_inset

, then we need to construct a Merkle tree of aggregated public keys for
 all combinations we can use: 
\begin_inset Formula $(P1,P2)$
\end_inset

, 
\begin_inset Formula $(P2,P3)$
\end_inset

, 
\begin_inset Formula $(P1,P3)$
\end_inset

 and put the root in the locking script.
 To spend bitcoins we provide a signature and a proof that our public keys
 is in the tree.
 For 2-of-3 multisig there are only 3 elements in the tree and the proof
 will consist fo two hashes-the one we want to use and its neighbor.
 For a 7-of-11 multisig there will be already 11!/7!/4!=300 possible key
 combinations and the proof will require 8 elements.
 In general the number of elements in the proof scales almost linear with
 the number of keys in multisig (its 
\begin_inset Formula $log2(n!m!/(n-m)!).$
\end_inset


\end_layout

\begin_layout Standard
But with the Merkle tree of public keys we are not limited to 
\emph on
m-of-n
\emph default
 multi-signatures.
 We can make a tree with any public keys we want.
 For example , if we have a laptop, a phone, a hardware wallet and a recovery
 seed, we can construct a structure that would allow us to spend bitcoins
 with a laptop and a hardware wallet, a phone and a hardware wallet or just
 with a recovery seed.
 This is currently not possible just with OP_CHECKMULTISIG- only if you
 construct much more complicated script with branches.
\end_layout

\begin_layout Section
Applications 
\end_layout

\begin_layout Standard
Each input contains a signature of a modified version of the transaction
 to be validated with its referenced output's key.
 In fact some outputs even require multiple signatures to be spent.
 Transactions spending such an output are often referred to as 
\emph on
m
\emph default
-of-
\emph on
n 
\emph default
multi-signature transactions [And11], and the current implementation correspondi
ng to the trivial way of building a multi-signature scheme by concatenating
 individual signatures.
 Additionally, a threshold policy can be enforced where only 
\begin_inset Formula $m$
\end_inset

 valid signatures out of the 
\begin_inset Formula $n$
\end_inset

 possible ones are needed to redeem the transaction (again this is the most
 straightforward way to turn a multi-signature scheme into some kind of
 basic threshold signature scheme).
\end_layout

\begin_layout Standard
Today Bitcoin uses ECDSA signatures [ANS05][NIS13] over the 
\begin_inset Formula $\mathsf{secp256k1}$
\end_inset

 curve [SEC10] to authenticate transactions.
 As Bitcoin nodes fully verify all transactions, signature size and verification
 time are important design considerations while signing time is much less
 so.
 Besides, signatures account for a large part of the size of Bitcoin transaction
s.
 Because of this, using multi-signatures seems appealing.
 However, designing multiparty ECDSA signature schemes is notably cumbersome
 [MR01][GGN16][Lin17]due to the modular inversion involved in signing, and
 moving to Schnorr signatures would definitely help deploy compact multi-signatu
res.
 While several multi-signature schemes could off an improvement over the
 currently available method, two properties increase the possible impact:
\end_layout

\begin_layout Itemize
The availability of key aggregation removes the need for verifiers to see
 all the involved key, improving bandwidth, privacy, and validation cost
\end_layout

\begin_layout Itemize
Security under the 
\emph on
plain public-key model 
\emph default
enables multi-signatures across multiple inputs of a transaction, where
 the choice of signers cannot be committed to in advance.
 This greatly increases the number of situations in which mulit-signatures
 are beneficial.
\end_layout

\begin_layout Subsection
Introduction 
\end_layout

\begin_layout Standard
Bitcoin contains every transaction since the system's inception, resulting
 in a final state, the set of unspent coins.
 Each unspent coin has an associated value (expressed as a multiple of the
 currency unit, 
\begin_inset Formula $10^{-8}$
\end_inset

 bitcoin) and a programmable public key of the owner.
 Every transaction consumes one or more coins, providing a signature for
 each to authorize its spending, and creates one more new coins, with a
 total value not larger than the value of the consumed coins.
 
\end_layout

\begin_layout Standard
Bitcoins uses a programmable generalization of a digital signature scheme.
 Instead of a public key, a predicate that determines spend-ability is included
 in every output (implemented in a concise programming language, called
 
\emph on
Bitcoin Script).
 
\emph default
When spending, instead of a signature, a witness that satisfies the predicate
 is provided.
 In practice, most output predicates effectively correspond to a single
 ECDSA verification.
 This is also how Bitcoin supports a naive version of multi-signatures with
 a threshold policy: coins can be assigned a predicate that requires valid
 signatures for multiple public keys.
 Several use cases for the exist, including low-trust escrow services [GBGN17]
 and split-device security.
 While using the predicate language to implement multi-signatures is very
 flexible, it is inefficient in terms of size, computational cost, and privacy.
 
\end_layout

\begin_layout Standard
As a global consensus system, kept in check by the ability for every participant
 to validate all updates to the ledger, the size of signatures and predicates,
 and the computational cost for verifying them are the primary limiting
 factors for its scalability.
 The computational requirements for signing, or the communication overhead
 between different signers are far less constrained.
 Bitcoin does not have any central trusted party, so it is not generally
 possible to introduce new cryptographic schemes that require a trusted
 setup.
 Finally, to function as a currency, a high degree of fungibility and privacy
 is desirable.
 Among other things, this means that ideally the predicate of coins fo not
 lead information about the owner.
 In particular, if several styles of predicates are in use, the choice may
 reveal what software or service is being used to manage it.
 
\end_layout

\begin_layout Subsection
Native multi-signature support 
\end_layout

\begin_layout Standard
An obvious improvement is to replace the need for implementing 
\emph on
n-
\emph default
of-
\emph on
n 
\emph default
multi-signatures in an ad-hoc fashion with a constant-size multi-signature
 primitive like Bellare-Neven, While this is on itself an improvement in
 terms of size, it still requires the predicate itself-whose size also matters-
 to contain all of the signers' public keys.
 Key aggregation improves upon this further, as a single-key predicate can
 be used instead which is both smaller and has lower computational cost
 for verification.
 It also improves privacy, as the participant keys and their count remain
 private to the signers.
 
\end_layout

\begin_layout Standard
When generalizing to the 
\begin_inset Formula $m\mathcal{}$
\end_inset

-of-
\begin_inset Formula $n$
\end_inset

scenario, several options exist.
 One is to forego key aggregation, and still include all potential signer
 keys in the predicates while still only producing a single signature for
 the chosen combination of keys.
 Alternatively, a Merkle tree [Mer87] where the leaves are permitted combination
s of keys (in aggregated form) can be employed.
 The predicate in this case would take as input an aggregated public key,
 a signature with it, and a proof.
 Its validity would depend on the signature being valid with the provided
 key, and the proof establishing that the key is in fact one the leaves
 of the Merkle tree, identified by its root hash.
 This approach is very generic, as it works for any subset of combinations
 of keys, and as a result has very good privacy as the exact is not visible
 from the proof.
 It is only feasible however when the total number of combinations is tractable.
 
\end_layout

\begin_layout Standard
Some key aggregation schemes that do not protect against rogue-key attacks
 can be used instead in the above cases, under the assumption that the sender
 is given a proof of knowledge/possession for the receivers' private keys.
 However, these schemes are difficult to prove secure except by using very
 large proofs of knowledge [MOR01].
 As those proofs of knowledge/possession for the receivers' private keys.
 However, these schemes are difficult to prove secure except by using very
 large proofs of knowledge/possession do not need to be seen by verifiers
 they are effectively certified by the sender's signature on the transaction
 which includes the predicate- they do not burden validation.
 However, passing them around to senders is inconvenient, and easy to get
 wrong .Using a scheme that is secure in the 
\emph on
plain public-key model 
\emph default
categorically avoids these concerns.
 
\end_layout

\begin_layout Standard
Another alternative is to use an algorithm whose key generation requires
 a trusted setup, for example in the KOSK model.
 While many of these schemes have been proven secure [Bol03, LOS+06], they
 rely on mechanisms that are usually not implemented by certification authoritie
s [BN06, RY07].
 
\end_layout

\begin_layout Subsection
Cross-input multi-signatures 
\end_layout

\begin_layout Standard
The previous sections explained how the numbers of signatures per input
 can generally by reduced to one, but we would like to go further, and replace
 it with a single signature per transaction.
 Doing so requires a fundamental change in validation semantics, as the
 validity of separate inputs is not longer independent.
 As a result , the outputs can no longer be modeled as predicates.
 Instead, we model them as functions that return a boolean plus a set of
 zero or more public keys.
 
\end_layout

\begin_layout Standard
Overall validity requires all returned booleans to be True and a multi-signature
 of the transaction with 
\begin_inset Formula $L$
\end_inset

 the union of all returned keys.
 
\end_layout

\begin_layout Standard
More concretely, this can be implemented by providing an alternative to
 the signature checking opcode OP_CHECKSIG and related opcodes in the Script
 language.
 Instead of returning the result of an actual ECDSA verification, they always
 return True, but additionally add the public key with which the verification
 would have taken place to a transaction-wide multi-set of keys.
 Finally, after all inputs are verified, a multi-signature present in the
 transaction is verified against that multi-set.
 In case the transaction spends inputs from multiple owners, they will need
 to collaborate to produce the multi-signature, or choose to only use the
 original opcodes.
 Adding these new opcodes is possible in backward-compatible way.
 
\end_layout

\begin_layout Subsection
Protection against rogue-key Attacks 
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
When taking cross-input signatures input signatures, there is no published
 commitment to the set of signers, as each transaction input can independently
 spend an output that requires authorization from distinct participants.
 This functionality was not restricted as it would then interfere with fungibili
ty improvements like CoinJoin [Max13].
 Due to the lack of certification, security against rogue-key attacks is
 of great importance.
 
\end_layout

\begin_layout Standard
If it is assumed that transactions used a single multi-signature that was
 vulnerable to rogue-attacks, like the simpler schemes previously described,
 an attacker could identify an arbitrary number of outputs he wants to steal,
 with the public keys 
\begin_inset Formula $X_{1},...,X_{n-t}$
\end_inset

 and then use the rogue-key 
\begin_inset Formula $X_{n-t+1},...,X_{n}$
\end_inset

 such that he can sign for the aggregated key 
\begin_inset Formula $\tilde{X}.$
\end_inset

He would then send a small amount of his own money to outputs with predicates
 corresponding to the keys 
\begin_inset Formula $X_{n-t+1},...,X_{n}$
\end_inset

.
 Finally, he can create a transaction that spends all of the victim coins
 together with the ones he just created by forging a multi-signature for
 the whole transaction.
 
\end_layout

\begin_layout Standard
It can be seen that in the case of mulit-signatures across inputs, theft
 can occur by merely being able to forge a signature over a set of keys
 that includes at least one key not controlled by the attacker, just what
 the 
\emph on
plain public-key model 
\emph default
considers a win for the attacker.
 This is in contrast to the single-inout multi-signature case where theft
 is only possible by forging a signature for the exact (aggregated)keys
 contained in an existing output.
 As a result, it is no longer possible to rely on proofs of knowledge/possession
 that are private to the signers.
 
\end_layout

\begin_layout Standard
To analyze the impact of multi-signatures, a simulation on Bitcoin's historical
 blockchain was performed to determine the potential space saving.
 Figure 3 shows the cumulative blockchain size together with what the size
 would be if all transactions' signatures were replaced with just one per
 transition, giving an indication of what could have been saved if 
\begin_inset Formula $\mathsf{MuSig}$
\end_inset

 had been used since the beginning.
 Note that this only encompasses the savings from using multi-signatures,
 and does not induce the savings that are possible from key aggregation.
 
\end_layout

\begin_layout Subsection
\begin_inset Formula $m-of-n$
\end_inset

 multi-signatures 
\end_layout

\begin_layout Standard
Muti-signatures refer to requiring more than one key to authorize a transaction.
 Currently, standard transactions on the Bitcoin network can be referred
 to as single-signature transactions, as they require only one signature,
 from the owner of the private key associated with the Bitcoin address.
 However, the Bitcoin network supports much more complicated transactions
 which can require the signatures of multiple people before the funds can
 be transferred.
 These are often referred to as m-of-n transactions, where m represents
 the signatures required to spend, while n represents the signatures possible.
\begin_inset CommandInset citation
LatexCommand cite
key "Contributors2017"
literal "false"

\end_inset

 
\end_layout

\begin_layout Subsubsection
Use cases for multi-signatures
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $m=1$
\end_inset

 and 
\begin_inset Formula $n>1$
\end_inset

, this shared wallet could be used for small group funds that do not require
 much security.
 It is the least secure multi-sig option because it is not multi-factor.
 Any compromised individual would jeopardize the entire group.
 Examples of use cases include funds for a weekend or evening event, or
 a shared walled for some kind of game.
 Besides being convenient to spend from, the only benefit of this setup
 is that all but one of the backup/password pairs could be lost and all
 of the funds would be recoverable.
 
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $m=n$
\end_inset

, there is a partner wallet, which brings with it some nervousness as no
 keys can be lost.
 As the number of signatures required increases, the risk also increases.
 This type of multi-signature can be considered as a hard multi-factor authentic
ation.
 
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $m<5n$
\end_inset

, it is considered a buddy account, which could be used for spending from
 corporate group funds.
 Consequence for the colluding minority need to greater than possible benefits.
 It is considered less convenient than a shared wallet, but much more secure.
 
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $m>5n$
\end_inset

, a consensus account is termed.
 The classic multi-signature wallet is a 2 of 3 and is a special case of
 a consensus account.
 2 of 3 has the best characteristics for creating new bitcoin addresses
 and for secure storing and spending.
 One compromised machine does not compromise the funds.
 A password can be lost and the funds can still be recovered.
 If done correctly, off-site backups are created during wallet setup.
 The way to recover funds is known by more than one party.
 The balance of power with a multi-signature wallet can be shifted by having
 one party control more keys than the other parties.
 If one party controls multiple keys, there is a greater risk of those keys
 not remaining as multiple factors.
 
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $m=5n$
\end_inset

, it is referred to as a split account, and is an interesting use case,
 as there would be 3 of 6 where one person holds 3 keys and 3 people hold
 1 key.
 In this way one person could control their own money, but the funds could
 still be recoverable even if the primary key holder were to disappear with
 all of his key.
 As 
\begin_inset Formula $n$
\end_inset

 increases, the level of trust in the secondary parties can decrease.
 A good use case might be a family savings account that would just automatically
 become an inheritance account if the primary account holder were to die.
\begin_inset CommandInset citation
LatexCommand cite
key "Contributors2017"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Boneh-Lynn-Shacham Signatures 
\end_layout

\begin_layout Standard
Boneh-Lynn-Shacham signature scheme is based on the computational Diffie-Hellman
 assumption on certain and hyper-elliptic curves.
 The signature length is half the size of a DSA signature for a similar
 level of security.
 
\end_layout

\begin_layout Standard
Schnorr signatures combine all signatures and public keys in the transaction
 into a single key and a signature and nobody will find out that they correspond
 to multiple keys.
 In addition block validation is faster, as all signatures can be validated
 at once.
 However there are a few problems with Schnorr signatures:
\end_layout

\begin_layout Itemize
Multisig schemes require several rounds of communication.
 This can be a hindrance with regards to cold storage
\end_layout

\begin_layout Itemize
With signature aggregation we have to rely on random number generator-we
 can't choose random point 
\begin_inset Formula $R$
\end_inset

 deterministically like we do in ECDSA
\end_layout

\begin_layout Itemize
m-of-n multisig scheme is tricky- we need to make a merkle tree of public
 keys that can get pretty large for large m of n 
\end_layout

\begin_layout Itemize
We can't combine all signatures in the block to a single signature 
\end_layout

\begin_layout Standard
BLS signatures can fix all of the above.
 We don't need random numbers at all, all signatures in the block can be
 combined to a single signature, m-of-n multisig is very simple and we don't
 need several communication rounds between signers.
 In addition to that BLS signatures are 2 times shorter than Schnorr or
 ECDSA- signature is not a pair, but a single curve point 
\end_layout

\begin_layout Subsection
Hashing to the curve
\end_layout

\begin_layout Standard
Normally with ECDSA and Schnorr we hash the message and use this hash in
 the signing algorithm as a number.
 For BLS signatures we need a slightly modified hashing algorithm that hashes
 directly to the elliptic curve.
 The easiest way is to hash a message as usual and treat the result as an
 
\begin_inset Formula $x$
\end_inset

-coordinate of a point.
 Elliptic curves usually have about 
\begin_inset Formula $2^{256}$
\end_inset

 points and SHA-256 hashing algorithm also gives a 256-bit result.
 But for every valid 
\begin_inset Formula $x$
\end_inset

-coordinate there are two points with positive and negative 
\begin_inset Formula $y$
\end_inset

-coordinate (just because if 
\begin_inset Formula $(x,y)$
\end_inset

is on the curve 
\begin_inset Formula $y^{2}=x^{3}+ax+b$
\end_inset

 then 
\begin_inset Formula $(x,-y)$
\end_inset

is also on the curve).
 This means that our hash has roughly 50% probability to find two points
 for some 
\begin_inset Formula $x$
\end_inset

and 50% to find none.
 
\end_layout

\begin_layout Standard
To find a point for any message we can try hashing several times by appending
 a number to the hash and incrementing it on fail.
 
\end_layout

\begin_layout Subsection
Key aggregation and n-of-n multisignature
\end_layout

\begin_layout Standard
If we are using multisignature addresses, we are signing the same transaction
 with different keys.
 In this case, we can do key aggregation like in Schnorr, where we combine
 all signatures and all keys to a single pair of a key and a signature.
 If we consider a common 3-of-3 multisig scheme:
\end_layout

\begin_layout Standard
A simple way to combine them is to add all the signatures and all the keys
 together.
 The result will be a signature 
\begin_inset Formula $S=S1+S2+S3$
\end_inset

 and a key 
\begin_inset Formula $P=P1+P2+P3$
\end_inset

.
 It is easy to see that the same verification equation still works:
\end_layout

\begin_layout Standard
\begin_inset Formula $e(G,S)=e(P,H(m))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $e((G,S)=e(G,S1+S2+S3)=e(G,(pk1+pk2+pk3)H(m))=e((pk1+pk2+pk3)GH((m))=e(P1+P2+P3,H(m))=e(P,H(m))$
\end_inset


\end_layout

\begin_layout Standard
Similarly to Schnorr there needs to be protection against rogue key attacks.
 This can be achieved by asking every co-signer to prove that they have
 private keys for their public keys (by signing their public keys), or that
 some nonlinearity to the scheme is added making rogue key attacks impossible.
 Instead of summing up all the keys and signatures, we multiply them by
 a certain number and then add:
\end_layout

\begin_layout Standard
\begin_inset Formula $S=a1S1+a2S2+aS3$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $P=a1P1+a2P2+a3P3$
\end_inset


\end_layout

\begin_layout Standard
Here coefficients of the signatures and keys are calculated deterministically
 from the public key of the signer and all other public keys:
\end_layout

\begin_layout Standard
\begin_inset Formula $ai=hash(Pi,\{P1,P2,P3\})$
\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "../Documents/The MuSig Schnorr Signature Scheme"
options "IEEEtran"

\end_inset


\end_layout

\end_body
\end_document
